[
{
	"uri": "https://cornell-netlab.github.io/MicroP4/installation/",
	"title": "Installing μP4",
	"tags": [],
	"description": "",
	"content": "This webpage provides instructions to build and install μP4, and reproduce the results from the paper \u0026ldquo;Composing Dataplane Programs with μP4\u0026rdquo;.\n As a pre-built VM. Building and installing μP4 from source.  Note: μP4 supports both v1model and Barefoot\u0026rsquo;s TNA architectures. For compiling programs for v1model, all the dependencies are publicly available. However, if you would like to compile programs for TNA, you would need access to Barefoot\u0026rsquo;s proprietary SDE (version 9.0.0). Accordingly, the pre-built VM has tools to support only the v1model. You would need to install Barefoot\u0026rsquo;s SDE yourself to support TNA.\nPre-built VM We provide a VM with μP4, along with all the dependencies, pre-installed here: μP4 VM (2.8 GB) (md5sum: 95dd2959f71970d648f32be3a6144cf9).\n Install and start Virtualbox on your machine. Download μP4 VM image, and import it to Virtualbox by selecting \u0026ldquo;File\u0026rdquo; -\u0026gt; \u0026ldquo;Import Appliance\u0026rdquo; in Virtualbox. If prompted, it\u0026rsquo;s safe to ignore warnings related to Virtualbox Guest Additions. Allocate the VM as much RAM as possible (at least 2GB) and two processors. Building p4c and BMv2 software switch from source can be resource intensive. The VM comes with these pre-built and installed. In case you want to rebuild them within the VM, allocate more resources. You may need to turn on virtualization extensions in your BIOS to enable 64-bit virtualization. When the VM starts up, the microp4 user should be automatically logged in. (username: microp4, password: microp4). (Optional) Get the latest version of μP4: cd microp4 \u0026amp;\u0026amp; git pull. Then, to build it, do cd build \u0026amp;\u0026amp; make -j2. (The complete build instructions are here https://github.com/cornell-netlab/MicroP4#22-build-and-install-%CE%BCp4c in case you would like to build it from scratch. p4c and BMv2 software switch are already installed on the VM, and you would not need to re-build them normally.) Next step: you can directly jump to building and testing composed programs by following the instructions here: https://github.com/cornell-netlab/MicroP4/tree/master/extensions/csa/msa-examples.  Video: We have also shared a video illustrating the steps and what to expect here:\n  Note: The VM does not include Barefoot\u0026rsquo;s SDE. You will need to install it yourself on your local machine and compile the generated P4 programs following the instructions provided with the SDE. We have tested the Tofino backend with a native OS installation only, and not with the VM.\nFrom Source We have released the source code for μP4 at https://github.com/cornell-netlab/MicroP4/ under an open-source license.\nTo build and install μP4, follow the instructions at: https://github.com/cornell-netlab/MicroP4/tree/master#getting-started.\nVideo: We have also shared a video illustrating the steps and what to expect. We used these steps to build the VM mentioned above.\n  "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/usage/",
	"title": "Using μP4",
	"tags": [],
	"description": "",
	"content": "Functionality: Examples from SIGCOMM \u0026lsquo;20 paper To reproduce the examples from our SIGCOMM \u0026lsquo;20 paper, see the code and instructions here: extensions/csa/msa-examples. In short, there are 7 composed programs mentioned in the paper. All of them can be compiler using a single Makefile as mentioned in the README.\n   Program in paper Composed μP4 program source Functions composed     P1 main-programs/routerv6_main.up4 Eth + IPv6   P2 main-programs/routerv46lrx_main.up4 Eth + IPv4 + IPv6 + MPLS   P3 main-programs/router_ipv4v6srv6_main.up4 Eth + IPv4 + IPv6 + SRv6   P4 main-programs/routerv46_main.up4 Eth + IPv4 + IPv6   P5 main-programs/routerv4_main.up4 Eth + IPv4   P6 main-programs/router_ipv4v6_nat_acl.up4 Eth + IPv4 + IPv6 + NAT + NPT6 + ACL   P7 main-programs/router_ipv4srv4ipv6_main.up4 Eth + IPv4 + IPv6 + SRv4    The videos from the installation step also show the usage: https://www.youtube.com/watch?v=ZtmLH0UFeqw\u0026amp;t=77s\nReusability: The framework can be used to write, compose and build new dataplane programs. We are working on a step-by-step tutorial to get you started with programming with μP4. At a high-level, There are two steps in using μP4:\n Writing μP4 programs: See this page for instructions on writing new programs. Compiling μP4 programs: See this page for instructions on compiling μP4 programs with μP4C.   -- "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/contributors/",
	"title": "Contributors",
	"tags": [],
	"description": "",
	"content": " Hardik Soni, Cornell University Myriana Rifai, Nokia-Bell Labs Praveen Kumar, Cornell University Ryan Doenges, Cornell University Nate Foster, Cornell University  "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/",
	"title": "Composing Dataplane Programs with μP4",
	"tags": [],
	"description": "A compiler to build dataplane of network devices using portable, modular and composable programs.",
	"content": "Dataplane languages like P4 enable flexible and efficient packet-processing using domain-specific primitives such as programmable parsers and match-action tables. Unfortunately, P4 programs tend to be monolithic and tightly coupled to the hardware architecture, which makes it hard to write programs in a portable and modular way—e.g., by composing reusable libraries of standard protocols\nTo address this challenge, we present the design and implementation of a novel framework (μP4) comprising a light-weight logical architecture that abstracts away from the structure of the underlying hardware pipelines and naturally supports powerful forms of program composition. Using examples, we show how μP4 enables modular programming. We present a prototype of the μP4 compiler that generates code for multiple lower-level architectures, including Barefoot’s Tofino Native Architecture.\nGoals   Portable  Programs written for one architecture, say PSA, should be easily reusable across other architectures, say v1model, without having to modify the source code. Following the “write-once, compile-anywhere” philosophy, programs should be loosely coupled to architectures and use general constructs that a compiler maps to architecture-specific constructs.      Modular  It should be possible to develop individual packet-processing functions in an independent manner agnostic of other dataplane functions. For example, one should be able to define Ethernet and IPv4 packet-processing functionality as separate module.      Composable  It should be easy to flexibly compose individual functions to construct larger dataplane programs. For example, imagine combining L2 Ethernet processing with IPv4, or any other L3 routing scheme (e.g., IPv6, MPLS etc.) with compatible interface and semantics, to obtain a modular router.     "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
