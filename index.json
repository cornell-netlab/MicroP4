[
{
	"uri": "https://cornell-netlab.github.io/MicroP4/usage/lib/",
	"title": "Compiling Libraries",
	"tags": [],
	"description": "",
	"content": "TODO: text "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/installation/",
	"title": "Installing μP4",
	"tags": [],
	"description": "",
	"content": "it is an extenstion of P4-16 "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/usage/",
	"title": "Compiling with μP4C",
	"tags": [],
	"description": "",
	"content": "two possible ways to compile Compiling Libraries   Generating P4-16    "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/usage/obj/",
	"title": "Generating P4-16",
	"tags": [],
	"description": "",
	"content": "TODO: text "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/contributors/",
	"title": "Contributors",
	"tags": [],
	"description": "",
	"content": "link to people "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/",
	"title": "Composing Dataplane Programs with μP4",
	"tags": [],
	"description": "A compiler to build dataplane of network devices using portable, modular and composable programs.",
	"content": "Dataplane languages like P4 enable flexible and efficient packet-processing using domain-specific primitives such as programmable parsers and match-action tables. Unfortunately, P4 programs tend to be monolithic and tightly coupled to the hardware architecture, which makes it hard to write programs in a portable and modular way—e.g., by composing reusable libraries of standard protocols\nTo address this challenge, we present the design and implementation of a novel framework (μP4) comprising a light-weight logical architecture that abstracts away from the structure of the underlying hardware pipelines and naturally supports powerful forms of program composition. Using examples, we show how μP4 enables modular programming. We present a prototype of the μP4 compiler that generates code for multiple lower-level architectures, including Barefoot’s Tofino Native Architecture.\nGoals   Portable  Programs written for one architecture, say PSA, should be easily reusable across other architectures, say v1model, without having to modify the source code. Following the “write-once, compile-anywhere” philosophy, programs should be loosely coupled to architectures and use general constructs that a compiler maps to architecture-specific constructs.      Modular  It should be possible to develop individual packet-processing functions in an independent manner agnostic of other dataplane functions. For example, one should be able to define Ethernet and IPv4 packet-processing functionality as separate module.      Composable  It should be easy to flexibly compose individual functions to construct larger dataplane programs. For example, imagine combining L2 Ethernet processing with IPv4, or any other L3 routing scheme (e.g., IPv6, MPLS etc.) with compatible interface and semantics, to obtain a modular router.     "
},
{
	"uri": "https://cornell-netlab.github.io/MicroP4/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
