#ifndef _EXTENSIONS_CSA_LINKER_DEPARSEREVALUATOR_H_
#define _EXTENSIONS_CSA_LINKER_DEPARSEREVALUATOR_H_

#include "ir/ir.h"
#include "frontends/common/resolveReferences/referenceMap.h"
#include "frontends/p4/typeChecking/typeChecker.h"
#include "frontends/p4/typeMap.h"
#include "midend/interpreter.h"

namespace CSA {

// Information produced for a parser by the symbolic evaluator
class DeparserInfo {
    const P4::ValueMap*                       before;
    P4::ValueMap*                             after;
    const DeparserInfo*                   predecessor;
  
    std::vector<size_t>                   currentIndex;

    size_t                                startStmtIndex;
    size_t                                endStmtIndex;
 

    IR::IndexedVector<IR::StatOrDecl>     programStack;
 public:
    DeparserInfo(size_t startStmtIndex, const DeparserInfo* predecessor, 
                 const P4::ValueMap* before) 
      : before(before), after(nullptr), predecessor(predecessor), 
        startStmtIndex(startStmtIndex), endStmtIndex(startStmtIndex) {}
};


// Stores entire execution tree generated by forking on every conditional in the
// deparser control block
class DeparserExecutionTree {
    const IR::P4Control*              deparser;
    const DeparserInfo*               execTreeRoot;
    std::vector<DeparserInfo*>        allExecNodes;
  
  public:
    DeparserExecutionTree(const IR::P4Control* p4Control, 
                          const DeparserInfo* execTreeRoot)
        : deparser(p4Control), execTreeRoot(execTreeRoot) {
    }
};


// Applied to a P4Parser object.
class DeparserEvaluator : public Transform {
    P4::ReferenceMap* refMap;
    P4::TypeMap* typeMap;
    DeparserExecutionTree* deparserControlInfo;
    const IR::P4Control* deparser;

 public:
    DeparserEvaluator(const P4::ReferenceMap* refMap, const P4::TypeMap* typeMap, 
                       DeparserExecutionTree* deparserControlInfo) {
        CHECK_NULL(refMap); CHECK_NULL(typeMap);
        // deparserControlInfo = new DeparserExecutionTree();
    }

    IR::Node* preorder(IR::P4Control* deparser) override;

    Visitor::profile_t init_apply(const IR::Node* node) override {
        LOG1("Scanning " << node);
        BUG_CHECK(node->is<IR::P4Control>(), "%1%: expected a deparser", node);
        /*
        auto control = node->to<IR::P4Control>();
        auto params = control->getApplyParameters();

        for (auto param : params->parameters) {
            auto type = typeMap->getType(param->type);
            // TODO: finish the check
        }*/
        return Transform::init_apply(node);
    }
};


}  // namespace CSA

#endif /* _EXTENSIONS_CSA_LINKER_DEPARSEREVALUATOR_H_ */
