\section{Introduction}
% hardware and software together, cool
Over the last decade, synergistic development of hardware and software systems based on match-action based abstraction has fundamentally changed packet processing in network devices.
In one hand packet processing chips based on the domain-specific hardware (e.g., RMT \cite{Bosshart:2013:FMF:2486001.2486011}, d-RMT \cite{Chole:2017:DDP:3098822.3098823}) provide a  great flexibility to reconfigure the data plane without modifying hardware of the target device, on the other hand P4 \cite{Bosshart:2014:PPP:2656877.2656890, p4lang} allows to program the re-configurable chips based target devices (e.g., TOFINO \cite{tofino}, FlexPipe etc.,).
P4 is designed to describe packet processing logic required in data plane of target devices to realize a network function and expose control plane APIs to configure the data plane objects.
% Using the APIs, Control plane can configure objects in data plane at run-time or compile time to achieve desired packet processing behavior or modify it.

%  What does it mean to have hardware and software targeted to specific domain.
% It did not mean we end up devloping mahcine langauge
Packet processing in data plane is primarily divided in three phases. $(1)$ Parsing headers, $(2)$ Headers and data modifications using match-action processing and $(3)$ Packet reassembly by deparsing.
The re-configurable hardware based targets provide of programmable packet processing blocks (Parser, match-action tables (MATs) and deparser) to support processing of each phase. 
P4 comprises of multiple sub-languages and each sub-language is designed to express logic for one or more types of programmable blocks. 
In addition, target devices may have function specific blocks (e.g., Packet Replication Engine to create copies of packets in the device).
All the packet processing blocks, programmable and fixed function, may be arranged in different layout in different target devices forming different pipelines and different architecture models (e.g., v1model\cite{v1model.p4}, PSA \cite{psa}) for packet processing.
P4 allows to express architectures of target devices using a sub-language.
This synergy between P4 and re-configurable hardware have greatly enhanced data plane programmability. 
However, the same synergy has created tight coupling between the language and target devices by exposing target-specific architecture details to programmers.
Therefore, reuse of code across different target devices is extremely difficult.


Even for the target devices with the same architecture and pipeline, P4 mandates to write a monolithic data plane program and carefully configure the data plane objects to build an application processing various protocols and performing multiple network functions.
For example, \texttt{switch.p4} \cite{switch.p4} has P4 code written to processes different protocol headers and network functions(e.g., l2 switching, l3 routing etc.,). 
But, the code globally share different types of metadata structures and parsed headers.
To program a target device only for ethernet switching using switch.p4, it is required to understand complete program and macros used in it to disable extraneous code.
Without understanding implementation details of the program with multiple features, it is difficult to reuse fine-grained fragments of code from it.
The difficulty arises due to absence of language constructs that can allow to define fine-grained packet processing modules with interfaces to communicate with them.
Existing data plane programming ecosystem needs modularity that allow programmers to expose interface to reuse code written to process packet at any granularity while abstracting away the implementation details.
% <<Why passing headers to controls as parameters is not good interface?
% Explain using innerIP, outer IP, ethernet, vxlan examples that passing headers does not provide unambiguous interface to process packet. 
% >>

\input{example}


Previous work, HyPer4 \cite{Hancock:2016:HUP:2999572.2999607}, HyperV \cite{8038396} use virtualization to support modularity.
P4Visor~\cite{Zheng:2018:PLV:3281411.3281436} supports testing specific composition operators(A-B and Differential) by merging P4 programs using compiler techniques.
In both approaches, minimal unit of re-usable code is an entire data plane program of a network function. 
These approaches may allow reuse of network functions but they can not allow selective reuse of fine-grained packet processing code from libraries of network functions.
Also, these approaches lack mechanisms to facilitate inter-module communication and define interface for the same.(e.g., next\_hop id in above example).
Encapsulating customized headers inside the packet may allow such communication, but that would require to know implementation details of deparser in one module to write complimentary parser in other and vice versa. 


The current ecosystem of programmable data plane enforces programmers to write code amenable to the target device's data plane architecture and pipeline.
Programmers write code for programmable blocks taking into account their location in pipeline rather than compilers automatically allocating code to the appropriate blocks.
We believe that devices should only expose abstraction for processing blocks and the onus of code allocation to the blocks in pipeline should be on compilers for the devices.

With this philosophy, we present a system, $\mu$P4, designed to enhance packet processing abstraction at target device level and enable code reuse across different targets.
$\mu$P4 consists of two components, Micro Switch Architecture ($\mu$SA) for a logical micro-switch target and a compiler, $\mu$P4C, for the logical target. 
$\mu$SA exposes simplified data plane pipelines and abstracts away fixed function blocks by providing logical constructs.
$\mu$SA allows programmers to define interface for code modules for easy reuse and write P4 code libraries.
Using $\mu$P4C, programmers can compile $\mu$SA specific code and independently developed libraries to a real target-specific single executable program or source.
In summary, we make following contributions.
\begin{itemize}
\item \textbf{Micro-Switch Architecture:} We introduce abstraction for fixed-function blocks and mechanisms to translate the abstractions into real target-specific functions using the compiler.
\item \textbf{Micro-Switch P4 compiler:} We show code transformations of parser and deparser blocks to match-action based control blocks that provides us flexibility to allocate code at appropriate blocks in pipeline of real targets.
\end{itemize}

Outline of the rest of the parer. 
First, we introduce technical challenges 
