\section{Overview Micro-P4 \;($\mu$P4)}
% Re-configurable targets process packets using multiple type of processing blocks and P4 provides multiple sub-languages following heterogenous abstract machines to program the blocks.
% The presence of heterogeneous abstract-machines and device-specific constructs is the
% primary reason for lack of mechanisms for modularity and code reuse.
% Because, it is not possible to define interface to reuse code modules when caller and callee modules can have incompatible abstract machines.

$\mu$P4 is a logical device providing abstraction for packet-processing pipelines in data planes of real target devices.
$\mu$P4 comprise of a switch architecture, $\mu$SA, and a compiler, $\mu$P4C for the logical device. 
$\mu$SA simplifies abstract machine for P4 data plane programs by exposing minimal number of programmable blocks required to implement.
It defines logical externs that allows programmers to express packet-processing logic relying on fixed-function blocks in real targets.
The generic interfaces defined in $\mu$SA allow to reuse code of fine-grained packet-processing functions on any real target devices.
We associate runtime behavior with the interfaces.
$\mu$P4C allows programmer to define, instantiated and invoke them package types using \texttt{apply} method calls.
% Also, programmers can build new functions using the code.
Using the generic interfaces along with logical externs, programmers can express \emph{sequential}, \emph{parallel} and \emph{multicast} exection of packet-processing functions to build new programs.
$\mu$P4C enables composition of packet-processing functions using P4 language itself \hs{in related work}\emph{without relying on different configuration languages like Hyper4 and P4Visor}.
It translates simplified abstract machine and its logical externs into real target-specific heterogeneous packet-processing blocks, features and constraints.
In this section, we introduce packet-processing model of $\mu$P4, generic interfaces and operation concepts.

\subsection{Packet Processing using $\mu$P4}
\label{subsection:packet-processing-using-mp4}
We model every packet-processing function as a black-box micro-switch that processes packet byte-stream, intrinsic metadata and arguments for user-defined parameters, as shown in Figure \ref{fig:package-runtime-behavior}.
The black-box model hides implementation details (headers types, user-defined metadata, programmable blocks etc.,) of micro-switch programs.
We augment micro-switch programs with input and output buffer queues.
Each element in the queue contains a packet byte-stream, intrinsic metadata associated with it and arguments.
In this model, the micro-switch program fetches an element from the input buffer to process at every execution step.
As a result of the processing, the program may generate one or more elements.
We enqueue them in output buffer queue.
\begin{figure}[h]
    \centering
    \includegraphics[trim=0 420 667 0, clip, scale=0.5]{microp4-program-model}
    \caption{Micro P4 Package Runtime Behavior}
    \label{fig:package-runtime-behavior}
\end{figure}

To realise this model, $\mu$SA defines multiple packet-pro\-cessing pipelines and each pipeline is associated with one or more generic interface types.
Each generic interface declares a set of programmable blocks to implement based on the associated pipeline model.
The interfaces allows programmers to specify user-defined types for the runtime parameters.
Programmers can implement the interfaces and define new \emph{package} types.
In control blocks of $\mu$SA pipelines, the package types can be instantiated and invoked by supplying arguments for the defined runtime parameters. 
% Packet-processing function need to expose concreate interface t 


\subsection{Compiling $\mu$P4 Programs}

\begin{figure}[!h]
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[trim=0 435 665 0, clip,scale=0.55]{mp4c-frontend}
        \caption{Library Program Compilation}
        \label{subfig:compiling-modules}
    \end{subfigure}
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[trim=0 407 628 0, clip,scale=0.55]{mp4c-compiler}
        \caption{Composition and Translation of Main Instance}
        \label{subfig:composition-translation-of-main-instance}
    \end{subfigure}
\caption{Compiling $\mu$SA programs}
\label{fig:compiling-msa-programs}
\end{figure}


\subsubsection{Sequential Execution}
\label{subsubsection:sequential-execution}
Sequential execution of micro-switch programs follow a single-thread model.
Only one micro-switch program processes a packet at a time.
$\mu$P4 allows programmers to invoke micro-switch programs using their interfaces in body of control blocks other micro-switch program.
Programmers can logical externs defined in $\mu$SA to express sequential processing.
Figure \ref{fig:sequential-execution} illustrates reuse of the code shown in Figure \ref{fig:l3.p4.l2.p4} to build a routing function, called emph{l2l3}.
 \begin{figure}[ht]
\begin{lstlisting}[frame=none]
// interfaces for l3 and l2
l3(pkt_in, pkt_out, sm_t, es_t, out bit<16>);
l2(pkt_in, pkt_out, sm_t, es_t, in bit<16>);

control l2l3(pkt_in pin, pkt_out po, 
             sm_t s, es_t e) {
  bit<16> next_hop; pkt_in pin_l2;
  apply {
    l3.apply(pi, po, s, es, next_hop);
    // sets `pin_l2' with `po's bytes, resets `po'
    po.get_pkt_in(pin_l2); // extern method call
    l2.apply(pin_l2, po, s, es, next_hop);
  }
}
\end{lstlisting}
\caption{Sequential Execution}
\label{fig:sequential-execution}
\end{figure}

\subsubsection{Parallel Execution}
\label{subsubsection:parallel-execution}
In parallel execution of multiple micro-switch programs, each program processes its own copy of a packet.
Programmers can create copies of a packet using logical constructs defined in $\mu$SA.
Figure \ref{fig:parallel-execution} shows a code snippet of a micro-switch program, called \emph{rm}, performing routing and mirroring.
It executes micro-programs \emph{l2l3} (Figure \ref{fig:sequential-execution}) and \emph{mirror} (samples traffic) in parallel.
\begin{figure}[ht]
\begin{lstlisting}[frame=none]
// interface for traffic mirror function
mirror (pkt_in, pkt_out, sm_t);
l2l3 (pkt_in, pkt_out, sm_t);
struct e_t {};
control rm(in_buf<e_t> ib, out_buf<e_t> ob) {
  pkt_in pin, pin_m; es_t es_m;
  pkt_out po_m; sm_t sm, sm_m;
  apply {
    ib.dequeue(pin, sm, es);
    // copies for parallel execution
    pin_m.copy_from(pin); sm_m = sm; 
    es_m.copy_from(es)
    mirror.apply(pin_m, po_m, sm_m, es_m);
    l2l3.apply(pin, po, sm, es);
    // synchronize and put in out_buf arg
    ob.enqueue(po, sm, es);
    ob.enqueue(po_m, sm_m, es_m);
  }
}
\end{lstlisting}
\caption{Parallel Execution}
\label{fig:parallel-execution}
\end{figure}

\subsubsection{Multicast Execution}
\label{subsubsection:multicast-execution}
Multicast execution differs from parallel execution in two fundamental aspects.
$(1)$ Multicast execution allows to program packet replication at runtime.
$(2)$ Each copy of the replicated packet executes the same code.
% $\mu$SA defines a logical multicast engine, \texttt{mc\_engine\_t}, as an extern.
Figure \ref{fig:multicast-execution} shows an example of expressing multicast replication using logical externs defined in $\mu$SA.
\begin{figure}[ht]
\begin{lstlisting}[frame=none]
struct out_t { bit<16> data;}
control mc(pkt_in pi, sm_t sm, es_t es, 
        hs_t h, ia_t ia, mc_buf<hs_t, out_t> hb) {
  mc_engine_t mce;  pkt_inst_id_t id; 
  out_t  oa;
  table t{
    key = {} actions = { mce.set_mc_group; drop; }
  }
  table mac{
    key = { es.get_port(); } 
    actions = { mac_update; }
  }
  apply {
    id = mce.apply(es); // equivalent to fork in C
    mac.apply();
    hb.enqueue(h, sm, es, oa);
  }
}
control dep(pkt_out<o_a> ob, 
            mc_buf<hs_t, out_arg_t> hb) {
  hs_t hdrs; out_arg_t oa; pkt_out po;
  hb.dequeue(hdrs, sm, es, oa);
  // deparser code 
  ob.enqueue(po, sm, es, oa);
}
\end{lstlisting}
\caption{Multicast Execution}
\label{fig:multicast-execution}
\end{figure}


