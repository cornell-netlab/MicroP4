\section{$\mu$P4C Compiler}
\label{section-mp4c-compiler}
$\mu$P4 


\subsection{Parser Block Transformation}
\label{subsection:parser-block-transformation}
P4 parser blocks describe parse graphs as state machines.
Real target devices contain programmable parser module that can be programmed using parse graphs.
From the design of programmable parser~\cite{6665172}, we make following observations.
Programmable parsers are implemented using buffer, state machine logic, Ternary Content-Addressable Memories (TCAM) and Action RAM. 
TCAM matches values of current state, fields or variables to identify next state. 
Based on match, headers are copied from bit stream and current state is modified.
Programmable parsers essentially perform repeated match and action.
Also, we note that network packets are of finite length, hence they can be parsed in a finite number of ways.
Successful parsing of a packet is essentially finding a match for a finite number of bytes from finite set of values.
However, we need to extract all the bytes that might be required to perform match-actions from packets' bit streams.

We compute number of bytes required to extract in section~\ref{subsubsection:computing-size-of-byte-array}, followed by an algorithm to convert parser without loops and variable length headers, called \textit{simple parsers}, into a series of match-action tables.
Next, we explain loops unrolling and variable length headers removal techniques transforming every parser into a simple parser.
Finally, we discuss an optimization to reduce number of MATs to one.


\subsubsection{Computing Size of Byte Array}
\label{subsubsection:computing-size-of-byte-array}
We perform symbolic execution of parser, control and deparser blocks to determine size of byte array buffer.
Every~\texttt{extract} method call statement in parser states advances bit index by number of bits equal to the size of the header type of the instance passed as the argument.
Symbolic execution of a parser block enumerates every possible path from the start to the accept state in the parse graph and computes total number of bytes extracted on every path.
For program $p$'s parser, we define length $l_{p}(x)$ of a path $x$ from the start to the accept state in the parse graph as total number of bytes extracted.
And, the input buffer size for program $p$'s parser as $\mathcal{I}(p) = \max_{x}(l_{p}(x))$. 


Programs may increase or decrease size of packets, therefor considering only parser buffer size is not enough.
We analyse control and deparser blocks to determine maximum increase and decrease in packet size by the program.
Initially, we set the validity bit of all the headers instances that could be extracted by the parser. 
We perform symbolic execution of control blocks to evaluate validity of each header instance on every path of the control flow graph.
Any header instance not emitted in all the paths of deparser block is considered invalid, because such header instances will not increase size of the packet.
We compute maximum and minimum number of bytes that can be emitted by program $p$ and denote them as $\mathcal{O}_{m}(p)$ and $\mathcal{O}_{n}(p)$, respectively.
We define maximum decrease and increase in packet size by program $p$ as $\delta(p)$ and $\Delta(p)$, as shown in (\ref{decrease}) and (\ref{increase}).
\begin{align}
\delta(p)\; =& \; \begin{cases}
\mathcal{I}(p) - \mathcal{O}_{n}(p), & \text{ if } \mathcal{I}(p) > \mathcal{O}_{n}(p), \\
0, & \text{ else }
\end{cases} \label{decrease} \\
\Delta(p) \; =& \; \begin{cases}
\mathcal{O}_{m}(p) - \mathcal{I}(p), & \text{ if } \mathcal{O}_{m}(p) > \mathcal{I}(p), \\
0, & \text{ else } \label{increase}
\end{cases}
\end{align}

To process packets by a sequence of $N$ programs, we define extract length, $\mathcal{E}l_{S}$ and buffer length $\mathcal{B}l_{S}$, as shown in (\ref{extract-length-seq}) and (\ref{buffer-length-seq}).
$\mathcal{E}l_{S}$ denotes the maximum number of bytes that may be extracted as cumulative effect of deparsers and parsers of all the program in a sequence.
$\mathcal{B}l_{S}$ denotes the maximum number of bytes that may be emitted as cumulative effect of the deparsers of all the programs in a sequence.
Similarly, we define extract length, $\mathcal{E}l_{P}$ and buffer length $\mathcal{B}l_{P}$, as shown in (\ref{extract-length-par}) and (\ref{buffer-length-par}), to process packets by $N$ programs in parallel.
\begin{align}
\mathcal{E}l_{S} \; =& \; \max_{i} \left\{ \left( \sum_{j=0}^{j<i} \delta(j) \right)+ \mathcal{I}(i) \right\},&\;\;\;i  \in [0,N] \label{extract-length-seq} \\
\mathcal{B}l_{S} \; =& \; \left( \sum_{i=0}^{N} \Delta(i) \right)+ \mathcal{E}l_{S} & \label{buffer-length-seq} \\
\mathcal{E}l_{P} \; =& \; \max_{i} \left\{ \mathcal{I}(i) \right\},&\;\;\;i  \in [0,N] \label{extract-length-par} \\
\mathcal{B}l_{P} \; =& \; \max_{i} \left\{ \mathcal{I}(i) + \Delta(i) \right\},&\;\;\;i  \in [0,N]  \label{buffer-length-par}
\end{align}


\subsubsection{Simple Parser to MATs}
\label{subsubsection:simple-parser-to-mats}
% We create action stage using parserStatements and match stage using ~\texttt{transitionStatement}.
Every path enumerated by symbolic execution of a parser consists of evaluated instances of the parser states.
<<>Diagram>
Every evaluated instance of a state provides a set of extracted (valid) header instances and their start bit indices corresponding to the state and the path.
A parser state can be a part of multiple paths, thereby having multiple instances.

Moreover, P4 parser states consist of~\texttt{parser\-Statements} and~\texttt{transition\-Statement}.
The select expression in transition statement could be a header field, metadata or local variable declared in the parser.
The value of select expression of a state may depend on its ancestors' parser statements. <<as shown in diagram>>
Therefore, we perform Forward Substitution on select expressions in evaluated instances of states
% (https://dl.acm.org/citation.cfm?id=7904)
on each path and eliminate such data dependency.

We synthesise 1 bit local variables, called $visit$ bit, for each parser state to track the state transition of the parser's FSM.
For every evaluated instance of a parser state, we synthesise an action comprising its~\texttt{parser\-Statements} and replace extract method call statements to assignment statements.
The assignment statements copies bytes from the array to header instances' fields using start bit indices computed by symbolic execution for the evaluated state instance.
We insert~\texttt{setValid} method call statement for the extracted header instances.
We add assignment statement to set $visit$ bit of the parser state.

For every parser state, we create a match key comprising key-fields from three sources. 
$(1)$ Set of all its ancestors' $visit$ bit,
$(2)$ $visit$ bit of the state itself and
$(3)$ union of select expression of all of its evaluated instances.
In most cases, the union of select expression would have a single key-field, unless forward substitution has produced different expressions in the state's evaluated instances.

The~\texttt{start} being a special state has only one evaluated instance.
We create an action, called~\texttt{start\_action}, from the only instance of the start state.
Next, we visit parser states in topological order. 
We create match key for the current parser state as described above.
~\texttt{keysetExpression} and all possible paths represented $visit$ bit vector match-key entries are synthesised.
For each match key entry, we use appropriate action synthesised by next state's evaluated instance.

The apply body of the control block consists of an action call invalidating all the header instances, followed by the ~\texttt{start\_action} call and apply calls to the MATs created for parser states in topological order.



\subsubsection{Loops and Variable Length Headers Elimination}
\label{loops-and-variable-length-headers-elimination}

\subsubsection{Optimization}



\subsection{Deparser Block Transformation}

\subsection{Cross-Architecture Code Translation}
