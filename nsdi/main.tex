\documentclass[letterpaper,twocolumn,10pt]{article}
\usepackage{usenix2019_v3}
\usepackage{local}

\begin{document}
\date{}
\title{\Large \bf \ulang: Towards Compositional (Modular?) Dataplane Programming}
\author{{\rm Paper \#XXX}\\ Anonymous author(s)}
\maketitle

\begin{abstract}
Domain-specific languages such as P4 enable flexible and efficient
packet-processing using primitives such as programmable parsers and
re-configurable match-action tables. However, the P4 ecosystem exposes
details of the underlying architecture, which ties programs to
specific architectures and makes it difficult to write composeable
libraries of code that can be reused across many different programs.

To address this challenge, we present the design and implementation of
a logical target, MicroP4 (\ulang), that decouples P4 programs from
architecture-specific constructs and naturally supports composition.
We present the design of the \ulang logical architecture (\uarch),
which abstracts away from hardware-level details without sacrificing
expressiveness. Using realistic examples, we show how \ulang enables
modular programming and composition, and we present an implementation
of the \ucomp compiler that generates code for lower-level
architectures which are implemented by real target devices.
\end{abstract}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% INTRODUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}
Over the last decade, the synergistic development of packet-processing
hardware and software has fundamentally changed how networks are built
and operated. Hardware platforms such as
RMT~\cite{bosshart2013forwarding} provide tremendous flexibility for
customizing the forwarding plane without having to fabricate new
chips, while languages such as P4~\cite{bosshart2014p4, p4lang} enable
programmers to describe rich packet-processing functions in terms of
high-level abstractions such as parsers and match-action tables.

In order to support different kinds of targets (e.g., software
switches, ASICs, FPGAs, etc.), P4 allows programmable and
fixed-function blocks to be arranged into different layouts as
specified by an architecture declaration. For example, the Portable
Switch Architecture (PSA)~\cite{psa} models a switch with a
programmable parser, programmable ingress pipeline, fixed-function
scheduler and queues, programmable egress pipeline, and programmable
deparser (Figure \ref{subfig:psa-model}).  PSA programs supply P4 code
for each programmable block.  P4 also allows to specify
target-specific features and data as a part of the target's
architecture declaration.  PSA programs can use features and data
specific to the architecture in the code for programmable block.
While this design allows the language to flexibly accommodate a wide
range of targets, it also creates a tight coupling between programs
and architectures, which makes it difficult to write programs in a
compositional manner or reuse common code fragments in different
programs.

For example, \texttt{switch.p4}~\cite{switch.p4} handles several dozen
different protocols and functions (e.g., L2 switching, L3 routing,
tunneling, etc.,). But the code is written against a global collection
of metadata and parsed headers. To use the code in \texttt{switch.p4}
to implement an Ethernet switch, it would be necessary to detangle the
L2-specific functionality from the extraneous code in the rest of the
program. Without a detailed understanding of the overall structure of
the top-level program, it is difficult or impossible to reuse code
fragments at finer granularity.

Consider a simple scenario with two code fragments, as shown in
\cref{fig:l2.p4,fig:ipv4.p4}. The first code fragment, \texttt{l2},
parses the ethernet header, and modifies the ethernet addresses using
the next hop, which is supplied as an argument, and finally deparses
the packet.  The second code fragment, \texttt{ipv4}, parses the IPv4
header, uses longest-prefix matching to determine the next hop,
decrements the \texttt{ttl} field and, finally, deparses the packet.
Note that neither \texttt{ipv4} nor \texttt{l2} is a complete
packet-processing program: the former does not generate a functionally
correct packets, while the latter is parameterized on the next hop and
so does not specify forwarding behavior. However, we could use
\texttt{l2} with any other routing scheme (e.g., IPv6, MPLS, etc.) to
obtain a valid program.

\begin{figure}[ht]
\begin{lstlisting}[frame=none]
// l2
parser P(packet_in pin, out hdr_t ph) {
  state start { pin.extract(ph.eth); }
}
control Pipe(inout hdr_t ph, inout sm_t sm,
             in bit<16> nh_id_id) {
  action drop () {}
  action forward(bit<48> dest_mac, bit<48> src_mac, bit<8> port) {
    ph.eth.dstMac = dest_mac;
    ph.eth.srcMac = src_mac;
    sm.out_port = port;
  }
  table forward_tbl {
    key = { nh_id_id : exact; }
    actions = { process; drop; }
  }
  apply { forward_tbl.apply(); }
}
control D(packet_out po, in hdr_t ph) {
  apply { po.emit(ph.eth); }
}
\end{lstlisting}
\caption{Ethernet Processing}
\label{fig:l2.p4}
\end{figure}

\begin{figure}[ht]
\begin{lstlisting}[frame=none]
// ipv4
struct meta_t { bit<16> type; }
parser P(packet_in pin, out hdr_t ph, inout meta_t m) {
  state start {
    transition select(m.type) {
      0x0800: parse_ipv4;
    }
  }
  state parse_ipv4 {
    pin.extract(ph.ipv4);
    transition accept;
  }
}
control Pipe(inout hdr_t ph, out bit<16> nh_id_id, inout sm_t sm) {
  action process(bit<16> nh) {
    ph.ipv4.ttl = ph.ipv4 - 1;
    nh_id_id = nh; // setting out param
  }
  table ipv4_lpm_tbl {
    key = { ph.ipv4.dstAddr : lpm; }
    actions = { process; }
  }
  apply { ipv4_lpm_tbl.apply(); }
}
control D(packet_out po, in hdr_t ph) {
  apply { po.emit(ph.ipv4); }
}
\end{lstlisting}
\caption{IPv4 processing}
\label{fig:ipv4.p4}
\end{figure}

%% The current ecosystem of programmable data plane enforces programmers
%% to write code amenable to the target device's data plane architecture
%% and pipeline. Programmers write code for programmable blocks taking
%% into account their location in pipeline rather than compilers
%% automatically allocating code to the appropriate blocks. We believe
%% that devices should only expose abstraction for processing blocks and
%% the onus of code allocation to the blocks in pipeline should be on
%% compilers for the devices.

There is some prior work on modular composition of P4 programs.
Systems such as HyPer4 \cite{Hancock:2016:HUP:2999572.2999607},
HyperV~\cite{8038396}, and
P4Visor~\cite{Zheng:2018:PLV:3281411.3281436} provide constructs for
merging independent programs onto a single device. However, these
systems only handle programs that describe end-to-end
packet-processing functions. Hence, they lack mechanisms for enabling
selective reuse of library code, specifying interfaces between
modules, and facilitating inter-module communication. To write truly
modular P4 programs, a fundamentally different approach is needed.

To this end, this paper presents the design and implementation of
\ulang, a new architecture that provides fine-grained abstractions for
constructing dataplane programs. \ulang consists of two components: i)
Micro Switch Architecture (\uarch), which distills packet processing
to its essence, and abstracts away from device-specific structure, and
ii) a compiler, \ucomp, that maps one or more \uarch programs to a
standard PISA pipeline.

This paper makes the following contributions.
\todo{rethink contributions}
\begin{itemize}
\item We motivate the need for modular data plane programming using a
  series of realistic examples.
\item We introduce \uarch, a new P4 architecture designed to enable
  fine-grained composition of program snippets.
\item We develop techniques for compiling \uarch programs to the
  standard PISA model, including merging programs composed together 
  \hse{and scheduling them onto a single PISA pipeline}.
%   including merging programs composed together in
%   parallel or in sequence onto a single PISA pipeline.
\end{itemize}

% Although much work remains, we believe that \uarch represents a
% promising first step toward enabling modular data plane programs.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% DATAPLANE PROGRAMMING %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dataplane Programming}
\label{sec:background}
% Goals:
% i) implicit background on dataplane programming and highlight the
% key challenges, and
% ii) present the key insights of our approach

We briefly describe the current state of data plane programming using
P4 to understand challenges hindering modular development and reuse of
packet-processing code (\cref{sec:p4}). Then, we derive insights that
make modular dataplane programming achievable with \ulang
(\cref{sec:approach}).

\subsection{Challenges with current approach}
\label{sec:p4}
\todo{Clearly and precisely articulate the main challenges.}

% Brief background on P4 programming model and architecture
P4~\cite{bosshart2014p4} has emerged as a popular language for
specifying the packet processing behaviour of programmable switching
chips, such as Barefoot Tofino~\cite{tofino} and Cavium
Xpliant~\cite{xpliant}, which are based on a pipeline of match-action
tables~\cite{bosshart2013forwarding}. To support a variety of
\emph{targets}, the ecosystem expects manufacturers to provide a
target-specific framework to program the devices. The framework also
provides an \emph{architecture} definition, specified in P4, that acts
as the programming model and provides an abstract view of the target
pipeline. Specifically, an architecture, such as
\texttt{v1model}~\cite{v1model.p4}, for a target, such as
\texttt{simple\_switch} software switch~\cite{simple_switch.md},
specifies the dataplane pipeline model comprising a set of
programmable and fixed-function blocks, flow of user-defined and
target-specific (called intrinsic) metadata in the pipeline, and
semantics of target-specific actions and externs. For example,
\cref{fig:arch-example} shows dataplane pipelines and their packet
processing blocks defined in \texttt{v1model}~\cite{simple_switch.md}
and Portable Switch Architecture (PSA)~\cite{psa}.
\begin{figure}[tbh]
  \centering
  \includegraphics[width=\linewidth]{example-arch.pdf}
  \caption{Dataplane pipelines for example architectures}
  \label{fig:arch-example}
\end{figure}

To program a target device, one can use P4 to specify the behavior of
the programmable blocks exposed in the architecture of the target.
While this approach allows supporting multiple targets which share the
same architecture, it also makes the \emph{P4 programs tightly coupled
to the architecture} of the target. Such tight coupling makes it
impossible to reuse P4 programs across targets with different
architectures.



% NOTE: Two main points:
% 1) across architectures: because pipeline model is different, it
% hinders portability and code reuse
% 2) even on the same architecture, a P4 program consists of
% sub-languages with different abstract machines. So, modular
% composition of programs is not possible.
% NOTE: introduce terms such as "abstract machine" with definition or
% examples

% First explain the problem with different architectures
Architectures differ in the way their dataplane pipeline is arranged.
A P4 program written for a given architecture specifies the behaviour
of programmable blocks within the corresponding pipeline. So, if the
architecture changes, it is impossible to map the P4 program onto the
different pipeline for the new architecture without a complete
rewrite. For example, in \cref{fig:arch-example}, there is no obvious
way to map the functionality in PSA's ingress deparser to any
programmable block in v1model's pipeline. Doing so needs semantic
understanding of the blocks and manual rewriting of the program.

Moreover, current architectures expose certain target-specific
information and operations---such as intrinsic metadata,
target-specific actions and \emph{extern} functions (e.g., resubmit,
recirculate, clone, etc.)---to enable special processing such as
packet replication~\cite{simple_switch.md,psa}. While doing so
enhances features, it also makes programs being closely tied to
architectures and targets. More fundamentally, it breaks the notion of
abstraction needed to write modular and portable programs.  For
example, many P4 programs written for PSA heavily rely on using
intrinsic metadata supported by PSA, and such metadata is used across
the program in an unrestricted manner~\cite{switch.p4}; porting such
programs to a different architecture requires significant refactoring.


Further, the current approach also makes it hard to write modular and
composable code. To understand why, note that even for the same
target, the architecture usually contains packet-processing blocks
with heterogeneous execution models, also called \emph{abstract
machines}. For example, consider PSA in \cref{fig:arch-example}---the
parser block  is usually described using a sub-language of P4 which
uses Finite State Machines (FSM) as its abstract machine while the
control blocks are expressed in another sub-language whose abstract
machine models imperative control flow. As each abstract machine is
defined independently, there is no common interface that programmers
can write their packet-processing modules against. This lack of
uniform abstract machine and interface prevents packet-processing
modules to be composed together as composition requires modules to
have compatible interfaces. For example, in
\cref{fig:l2.p4,fig:ipv4.p4}, ideally we would like to execute the
\texttt{ipv4} module right before applying \texttt{forward\_tbl} in
\texttt{l2}'s \texttt{Pipe} control block so that \texttt{nh\_id} is
available in \texttt{forward\_tbl}. But, such composition is not
feasible currently.

\deleted{Specifically, Parser blocks are described using a sub-language of P4, based on abstraction of Finite State Machine. Control blocks are expressed using a sub-language modelling imperative control flow. Deparsers are special control blocks that allows to use statements, to reassemble packets, that are prohibited in other control blocks.
Packet-processing logic in P4 programs is partitioned across programmable blocks with heterogeneous abstract machines (e.g., parsers, deparsers, control) and fixed-function blocks (Packet Buffer and Replication Engine).
Incompatibility among abstract-machines, the absence of homogeneous one and fragmented execution flow in data plane hinders development of code modules with interfaces to reuse P4 code.
Consider the example in Figure \ref{fig:l2.p4}, parser \texttt{P} of \texttt{l2} can not be executed at the end of deparser control block \texttt{D} of \texttt{ipv4} Figure \ref{fig:ipv4.p4}.
}

Finally, architectures expose hardware-level constraints on intrinsic metadata of their targets to programmers.
For example, $(1)$ output port can not be changed in a given programmable block, $(2)$ scope of some intrinsic metadata limited to specific programmable blocks, etc..
Programmers implement packet-processing logic conforming to constraints, architecture model and semantics of actions and extern functions of the target device.

% Essentially, current ecosystem not only creates tight coupling between architectures and programs but also delegates responsibility of code allocation to programmers.

In summary, there are two main challenges for easy reuse of code with existing data plane programming ecosystem.
$(1)$ A lack of higher-level of abstraction for data plane pipeline to decoule P4 code from target devices and $(2)$ Absence of homogeneous abstract-machines or mechanism for seamless transition across heterogeneous abstract-machines involved in various packet-processing phases.



\subsection{Our approach}
\label{sec:approach}

To address these challenges without disrupting current ecosystem and
workflow of data plane programming in P4, we design a switch
architecture \uarch for an intermediate logical device, called \ucomp.
The data plane model with logical pipelines of \ucomp provides
abstractions for pipeline models of real-target architectures.  \uarch
provides a set of constructs to write modular code having interface to
reuse it and to hide its implementation details.  The logical pipeline
models defined in \uarch do not completely eliminate heterogeneity in
packet-processing blocks (parser, control) of the pipelines.
% However, constructs and pipeline models declared in \uarch allows to
% write programs by reusing the code developed in conformance of
% \uarch.
The design choices for \uarch are intentional to avoid disruptive
innovations in P4 language.  It partially address the above mentioned
challenges and leaves following two aspects for unaddressed.  $1$
creating P4 programs specific to \uarch and the logical device \ucomp.
$2$ heterogeneity in packet-processing blocks of P4 programs.  We
complement design choices of \uarch by designing and developing a
compiler, \ucomp, to address these aspects.


\ucomp transforms \uarch-specific P4 code for a given real-target
architecture satisfying all the constraints and in conformance of
lower-level details of the target.  First, \ucomp estimates
operational region of packets to process the P4 code.  It synthesizes
a parser and a deparers blocks as declared in real-target
architecture.  Then, it transforms all parser and parser blocks into
match-action control blocks homogenizing abstract-machines for
packet-processing blocks.  This allows to natural transfer of
execution-control across modules, enabling modularity and facilitating
code reuse.  Finally, it allocates transformed match-action control
blocks to control blocks in pipeline model of target architecture
while translating \uarch-specific constructs to target
architecture-specific ones.






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% MICRO-P4 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{MicroP4}
\label{sec:microp4}
\ulang is an intermediate logical target with an abstract packet-processing model.
It is designed to provide a higher-level logical abstraction for data plane pipelines to enable code reuse agnostic of architectures of target devices without compromising expressiveness and packet-processing features.
Also, it allows to write P4 code modules implementing fine-grained packet-processing functionality, to define interfaces and to hide implementation, enabling modular programming.
\ulang models every program as a black-box, \emph{Micro-Switch} ($\mu$s), that processes packet byte-stream, intrinsic metadata and arguments for user-defined parameters.
The black-box model hides implementation details (headers types, user-defined metadata, programmable blocks etc.,) of $\mu$-programs.
\ulang executes programs using the packet-processing model shown in Figure \ref{fig:mp4-packet-processing-model}.
\begin{figure}[h]
    \centering
    \includegraphics[trim=0 420 667 0, clip, scale=0.5]{microp4-program-model}
    \caption{Packet-Processing model of $\mu$s-programs}
    \label{fig:mp4-packet-processing-model}
\end{figure}
\ulang fetches an element from a logical input buffer queue, executes the program and writes one or more elements to a logical output buffer queue.
Every element of the buffers comprises a packet bit-stream, intrinsic metadata (e.g., ingress\_port, egress\_port, packet\_length etc., ) and input arguments or output arguments associated with the packet.


We design a Micro-Switch Architecture (\uarch) that defines data plane model with multiple logical pipelines to develop $\mu$s-programs.
Each logical pipeline is associated with an interface declared in the architecture.
Every interface specifies generic run-time parameters and declares programmable blocks required to be implemented for a pipeline.
\uarch data plane pipelines comprise of only programmable packet-processing blocks, parser, match-action control blocks and deparser. 
In addition, \uarch declares intrinsic metadata and logical externs to facilitate all the packet-processing features, e.g., multicast, cloning, that are not part of P4 language but supported by architectures of real-targets. 
Programmers can use the logical externs in \uarch pipelines to use such packet-processing features.
Using constructs declared in \uarch, programmers can write modules containing one or more $\mu$s-programs.
Each $\mu$s-program specializes a generic interface.
The run-time interfaces enable easy reuse and hide implementation detail of the $\mu$s-programs, facilitating modular and incremental development.
Using logical data plane model of \uarch, programmers can develop modular P4 code which is specific to \uarch.
We design and develop MicroP4 Compiler (\ucomp) to compile and transform $\mu$s-program for architectures of real target devices, making $\mu$s-programs agnostic of architectures of real-targets.

Programmer can use \ucomp to $(1)$ Create compiled libraries of $\mu$s-programs along with their control plane APIs, $(2)$ Link all the $\mu$s-programs used in the $\mu$s-program of main instance and transform the program for a specified architecture of a real-target.
If the given source file does not contain an instance named, \ucomp generates a library by compiling it to an Intermediate Representation (IR) in json format (Figure \ref{subfig:module-compilation}).
It also generates architecture-independent control-plane APIs, P4Runtime \cite{p4runtime} files.
If the source file contains \emph{main} instance, it links all the supplied libraries and transforms the $\mu$s-program of main instance for a given architecture (Figure \ref{subfig:compilation-to-target-architecture}).
\begin{figure}[h]
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[trim=10 440 666 0, clip,scale=0.5]{mp4c-frontend.pdf}
         \caption{Module Compilation}
         \label{subfig:module-compilation}
    \end{subfigure}
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[trim=3 440 640 0, clip,scale=0.5]{mp4c-compiler}
        \caption{Compilation to a Target Architecture}
        \label{subfig:compilation-to-target-architecture}
    \end{subfigure}
    \caption{Compiling $\mu$s-programs}
\end{figure}
Programmers can include files containing definitions of data types (e.g., struct types of in and out parameters) used in run-time interfaces of $\mu$s-program in libraries.
\ucomp compiler generates either source P4 code for the specified architecture or an executable with architecture-specific CP APIs.


To write a $\mu$s-program, programmers need to define a custom P4 \texttt{package} type by implementing an interface for a logical pipeline.
\ucomp extends current P4 language and allows programmers to define \texttt{package} types, declare their instances and invoke them using the built-in \texttt{apply} method.
This allows to hide implementation of package types and reuse them using run-time parameters of their interfaces.


Programmers can use sub-languages of P4 for parser and control blocks to implement interfaces.
\ucomp.
\ucomp homogenizes abstract-machines of programmable blocks by transforming parser and deparser blocks into match-action control blocks.
This transformation unifies the abstract-machines for packet-processing allowing seamless transfer of execution control across $\mu$s-programs.


\ucomp perform static analysis to estimate possible packet sizes required to process all the transformed $\mu$s-programs in match-action control blocks of target architecture's pipeline.
\ucomp synthesizes P4 code for parser and deparer blocks of target architecture's pipeline to extract and emit required number of bytes from and to packet.
Next, \ucomp translates intrinsic metadata and logical externs into the target architecture-specific constructs.
It allocates and schedules code of transformed $\mu$s-programs to control blocks of the target architecture's pipeline model while satisfying constraints posed by hardware details.


\section{Micro Switch Architecture}
\label{sec:architecture}
Using the packet-processing model described in Figure \ref{fig:mp4-packet-processing-model}, we define $\mu$s-program interfaces and packet-processing pipelines for \ulang as a part of its data plane architecture, \uarch.
In addition, \uarch defines a set of logical externs providing various packet-processing constructs available in fixed-function blocks (e.g., packet duplication) of pipelines models of real-target architectures.

\subsection{Pipelines and Interfaces}
\label{sec:pipelines}
\uarch has two types logical pipeline, Micro and Orchestration, shown in Figure \ref{fig:msa-pipelines}
% \uarch's logical externs can be instantiated and used within control blocks of the \uarch pipelines.
Micro pipeline comprises of a Parser, a Micro control and a Deparser block.
\uarch does not allow conditional statements in deparser blocks of its pipelines.
For each pipeline type, it exposes one or more interface types.
Each interface type comprises of a set of declarations for programmable blocks and run-time signature.
\begin{figure}[ht]
    \centering
    \begin{subfigure}{0.59\linewidth}
        \centering
        \includegraphics[trim=0 482 692 0, clip,scale=0.45]{msa-pipeline}
        \caption{Micro}
%         \label{subfig:micro}
    \end{subfigure}\vline
    \begin{subfigure}{0.41\linewidth}
        \centering
        \includegraphics[trim=0 480 805 0,clip,scale=0.45]{micro-orchestration-pipeline}
        \caption{Orchestration}
%         \label{subfig:orchestration}
    \end{subfigure}
\caption{\uarch Pipelines}
\label{fig:msa-pipelines}
\end{figure}
Programmers can provide implementations of the interface types to create user-defined P4 package types.
To implement an interface type, programmers need to implement all the programmable blocks of the interface type.
Programmers can instantiate variable of user-defined package types and invoke the instances using built-in  \texttt{apply} method similar to control blocks.
The \texttt{apply} method of package instance can be called by supplying arguments for run-time parameters of the interface implemented by the package type.

Every incoming packet is parsed and validated by the parser, if parser terminates in \texttt{accept} state, then execution control is transferred to micro control block.
If the execution control reaches till the end of the micro control block, packet is processed by the deparser block.
Orchestration pipeline has only a control block, named orchestration.
\begin{figure*}
\begin{minipage}[t]{.35\textwidth}
\begin{lstlisting}[frame=none]
extern pkt {
  byte[] packet;
  unsigned length;
  void copy_from(pkt pa);
}
extern emitter {
  void emit<H>(pkt p, in H hdr);
}
\end{lstlisting}
\end{minipage}\vline
\hfill\begin{minipage}[t]{.22\textwidth}
\begin{lstlisting}[frame=none]
enum meta_t {
  INGRESS_TIMESTAMP,
  EGRESS_TIMESTAMP
}
struct sm_t {
  bit<16> pkt_len;
  bit<8> in_port;
}
\end{lstlisting}
\end{minipage}\vline
\hfill\begin{minipage}[t]{.41\textwidth}
\begin{lstlisting}[frame=none]
extern mc_engine {
  mc_engine();
  void set_mc_group(GroupId_t gid);
  apply(es_t, out PacketInstanceId_t);
  
  set_buf(out_buf<O>);
  apply(pkt, out sm_t, es_t, out O);  
}
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.40\textwidth}
\begin{lstlisting}[frame=none]
extern extractor {
  void extract<H>(pkt p, out H hdr);
  void extract<H>(pkt p, out H hdr, in bit<32> size);
  H lookahead<H>();
}
extern es_t {
  void set_out_port(in bit<8>);
  bit<8> get_out_port();
  bit<32> get_value(in meta_t ft);
  void copy_from(es_t es);
}
\end{lstlisting}
\end{minipage}\vline
\hfill\noindent\begin{minipage}[t]{0.57\textwidth}
\begin{lstlisting}[frame=none]
extern in_buf<I> { // used only by architecture
  dequeue(pkt, out sm_t, es_t, out I);
}
extern out_buf<O> {
  enqueue(pkt p, in sm_t sm, es_t es, in O out_args);
  void to_in_buf(in_buf<O>);
  void merge(out_buf<O>);
}
extern mc_buf<H, O> {
  enqueue(pkt, in H, in sm_t, es_t, in O);
}
extern void recirculate();
\end{lstlisting}
\end{minipage}
\caption{Declarations in Micro-Switch Architecture}
\label{fig:micro-switch-architecture}
\end{figure*}


\begin{lstlisting}[frame=none]
Unicast<H,M,I,O,IO>
  (pkt p, inout sm_t sm, es_t es, in I i_param, out O o_param, inout IO io_param) // Runtime Params
  {Par<H,M,I,O> p, Con<H,M,I,O,IO> c, Dep<H> d}; // Programmable Blocks
Multicast<H,M,I,O>
  (pkt p, in sm_t sm, es_t es, in I i_param, out_buf<O> ob)
  {Par<H,M,I> p, Con<H,M,I,O> c, Dep<H> d}; 
Orchestration<I,O>
  (in_buf<I> ib, out_buf<O> ob)
  {Con<I,O> c};
\end{lstlisting}
\uarch declares threes interface types, \texttt{Unicast}, \texttt{Multicast} and \texttt{Orchestration}.
Programmers can implement programmable blocks declared for Micro pipeline to create custom package types having run-time signature same as unicast or multicast interface.
Similarly, Orchestration interface is associated with Orchestration pipeline.
Figure \ref{fig:micro-switch-architecture} shows declarations of types used in the interfaces.
The \texttt{pkt} is an extern type representing packet. 
The \texttt{sm\_t} is struct type containing intrinsic metadata (e.g., in\_port, pkt\_len etc.,).
The \texttt{es\_t} extern represent intrinsic metadata related to output port of the packet in the pipeline along with queuing related metadata.
\texttt{in\_buf} and \texttt{out\_buf} externs represent logical input and output buffer of \ulang packet-processing model (Figure \ref{fig:mp4-packet-processing-model}).
Next, we give overview of logical externs defined in \uarch along with their example usage.

% It defines standard intrinsic metadata as \emph{sm\_t} as a struct type.
% The fields of this struct provide basic information populated by the target e.g., \emph{packet\_length}.

% Some fields are not mutable, however \uarch allows to declare instances of the struct and perform assignment operation between two instances to create copies.


\subsection{Logical Externs}
\label{sec:externs}

\subsubsection{Packet Extern}
\uarch models packets using an extern object, \texttt{pkt}, declared in \uarch (Figure \ref{fig:micro-switch-architecture}.
The \texttt{pkt} extern can be instantiated inside control blocks of only orchestration pipelines.
\ucomp mandates to initialize \texttt{pkt} instances in the control block using its \texttt{copy\_from} method.
The \texttt{pkt} extern object contains \texttt{copy\_from} having a parameter of its own type.
The \texttt{copy\_from} method initializes its calling instance with content of \texttt{pa} without modifying the argument.
\ulang considers this method as a compile-time known packet replication, whereas multicast as a run-time packet-replication described in Section \ref{sec:multicast}.
\uarch provides two externs objects, \texttt{extractor} and \texttt{emitter}, to facilitate data extraction from and insertion into packets.
The \texttt{extractor} and \texttt{emitter} externs can not be instantiated, their instances are provided by the architecture as parameters in parser and deparser declarations of Micro pipeline programmable blocks. 

\subsubsection{Correlated Intrinsic Metadata}
\uarch defines intrinsic metadata for the logical target \ulang.
For every real-target architecture , \ucomp maintains mapping of its logical intrinsic metadata with the metadata of the architecture.
This mapping is used for transforming $\mu$s-programs to a given architecture-specific code.
Many intrinsic per-packet metadata provided by architectures of real-target devices are correlated.
For example, many real-target devices allow to measure every packet's queuing latency through the device.
The timestamps required to compute queuing latency can be measured only after the packet's out port is finalized and packet is enqueued in appropriate queue.
\uarch abstracts away correlated intrinsic metadata using stateful logical externs.
It captures dependency among correlated intrinsic metadata using stateful extern objects.
It declares \texttt{es\_t} extern object with methods to manipulate and access correlated intrinsic metadata.
For example, \texttt{set\_out\_port} and \texttt{get\_out\_port} allow, respectively, to set and get output port for the packet.
In addition, \uarch declares an enumerator, called \texttt{meta\_t}.
Each value in the enumerator associated with a immutable intrinsic metadata populated by only target for every packet (e.g., \texttt{IN\_TIMESTAMP}, \texttt{OUT\_TIMESTAMP} etc).
The \texttt{es\_t} extern declares a two-parameters method, \texttt{get\_value}, that allows to read values populated by the target.
The first parameter with \texttt{in} direction is of \texttt{meta\_t} type indicating a particular metadata field.
The second parameter with \texttt{out} direction provides value of the field.

% \ucomp allows repeated usage of the extern's functions in the single control block of \uarch pipelines.
% If \emph{get\_value} occurs before \emph{set\_egress\_port} on any possible execution control path, \ucomp raises a compile-time error.



\begin{figure*}[!ht]
\noindent \begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[frame=none, escapechar=!]
/* ipv6.p4 */
header ipv6_h { ... }; 
struct ipv6_ht { ipv6_h ip };
parser P(extractor ex, pkt p, out ipv6_ht h) {
  state start {
    ex.extract(p, h.ip); transition accept;
  }
}
control C(pkt p, inout ipv6_ht h, inout sm_t sm, es_t es, out bit<16> nh_id) {
  action process(bit<16> nh) {
    h.ip.hopLimit = h.ip.hopLimit - 1;
    nh_id = nh;  // setting out param
  }
  table ipv6_lpm_tbl {
    key = { h.ip.dstAddr : lpm }
    actions = { process; }
  }
  apply { ipv6_lpm_tbl.apply(); }
}
control D(emitter em, pkt p, in ipv6_ht h) {
  apply { em.emit(p, h.ip); }
}!{\subcaption[]{ipv6 $\mu$s-program}\label{subfig:ipv6}}!
/* router.p4 */
// Declarations of !{\color{commentcolor}{$\mu$s-programs}}!
!\colorbox{mygray}{ipv6}!(pkt p, inout sm_t sm, es_t es, 
    out bit<16> nh_id);
!\colorbox{mygray}{ipv4}!(pkt p, inout sm_t sm, es_t es, 
    out bit<16> nh_id);
\end{lstlisting}% !\colorbox{mygray}{mpls}!(pkt p, inout sm_t sm, es_t es);
\end{minipage}\hspace{-4pt}\vline
\hfill\begin{minipage}[t]{.50\textwidth}
\begin{lstlisting}[frame=none, escapechar=!]
parser P(extractor ex, pkt p, out hdr_t h) {
  state start {
    ex.extract(p, h.eth); transition accept;
  }
}
control C(pkt p, inout hdr_t h, inout sm_t sm, es_t es) {
  !\colorbox{mygray}{bit<16> nh\_id; ipv4() ipv4\_i; ipv6() ipv6\_i;}!
  action drop () {}           
  action forward(bit<48> dmac, bit<48> smac, bit<8> port) {
    h.eth.dstMac = dmac; h.eth.srcMac = smac;
    es.set_out_port(port);
  }
  table forward_tbl {
    key = { nh_id : exact; } 
    actions = { forward; drop; }
  }
  apply {
    switch (h.eth.etherType) {
      0x0800:!\colorbox{mygray}{ipv4\_i.apply(p, sm, es, nh\_id);}!
      0x86DD:!\colorbox{mygray}{ipv6\_i.apply(p, sm, es, nh\_id);}!
    }
    forward_tbl.apply(); 
  }
}
control D(emitter em, pkt p, in hdr_t h) {
  apply { em.emit(p, h.eth); }
}
Router(P, C, D) main;
\end{lstlisting}
% 0x8847:!\colorbox{mygray}{mpls\_i.apply(p, sm, es);}!
\subcaption[]{Router's main $\mu$s-program}\label{subfig:router-main}
\end{minipage}
\caption[]{Modular Router using \uarch \footnotemark}
\label{fig:modular-router}
\end{figure*}
\footnotetext{The unused parameters in parser, control blocks and run-time signature of interface are skipped.}




\subsubsection*{Example $\mu$s-programs}
Figure \ref{fig:modular-router} shows a possible way to write modular data plane program for a router using interfaces and externs declared in \uarch.
The code snippet in (Figure \ref{subfig:ipv6}) defines \texttt{ipv6} as a package by implementing blocks of the \texttt{Unicast} interface.\footnotemark[\value{footnote}]
The \texttt{Router} program in Figure \ref{subfig:router-main}, parses the ethernet header and invokes appropriate layer-3 module(e.g., \texttt{ipv4 ipv6, mpls}) based on \texttt{etherType} in the header, shown in highlighted code.
The layer-3 modules are invoked by supplying partial packet (without ethernet header) along with intrinsic metadata and other data (\texttt{nh\_id}) as arguments.
\begin{figure}[!h]
\begin{subfigure}[b]{\linewidth}
 \begin{lstlisting}[frame=none]
// srv6.p4
header ext_routing_h { ... }; 
header srh_h { ... }; header ipv6_h { ... }; 
struct srv_ht { 
  ipv6_h ipv6; ext_routing_h er; srh_h sr;
};
parser P(extractor e, pkt p, out srv_ht h) {
  state start {
    e.extract(p, h.ipv6);
    transition select (h.ipv6.nextHdr) {
      0x2B : parse_routing_hdr; }
  }
  state parse_routing_hdr { ... }
  state parse_srh { ... }
}
control C(pkt p, inout srv_ht h, inout sm_t sm, es_t es) {
  apply { // copy next segment address from h.sr to h.ipv6.destAddr}
}
control D(emitter em, pkt p, in srv_ht h) {
  apply { 
    em.emit(p, h.ipv6);
    em.emit(p, h.er); em.emit(p, h.sr);
  }
}
\end{lstlisting}
\caption{srv6 $\mu$s-program to support IPv6 SRH}
\label{subfig:srv6}
\end{subfigure}
\begin{subfigure}[b]{\linewidth}
 \begin{lstlisting}[frame=none, escapechar=!]
apply {
  switch (h.eth.etherType) {
    0x86DD : { 
      !\colorbox{mygray}{srv6\_i.apply(p, sm, es);}!
      ipv6_i.apply(p, sm, es, nh_id);
    }
  }
  forward_tbl.apply(); 
}
\end{lstlisting}
\caption{Extending Modular Router}
\label{subfig:extending-modular-router}
\end{subfigure}
\caption{Incremental Development}
\label{fig:incremental-development}
\end{figure}
In the \texttt{Router} program, we can easily add support for yet another routing mechanism, SRv6, by independently developing a $\mu$s-program (Figure \ref{subfig:srv6}) processing IPv6 Segment Routing Header (SRH).
Figure \ref{subfig:extending-modular-router} shows a portion of code from modular router (Figure \ref{subfig:router-main}) to integrate \texttt{srv6} program.
We note that support for \texttt{srv6} is added without modifying $\mu$s-program of any other routing scheme.


\subsubsection{Multicast Extern}
\label{sec:multicast}
\ulang allows programmers to configure packet replication at run-time using a multicast extern , \texttt{mc\_engine}, declared in \uarch.
The \texttt{mc\_engine} can be instantiated inside control blocks of Micro pipelines implementing\texttt{Multicast} interface (Figure \ref{fig:multicast-example}).
The control block of \texttt{Multicast} interface provides \texttt{mc\_buf} as one of the parameters to store copies of parsed headers, unparsed packet, intrinsic metadata and argument data related to the packet.
Programmers can use \texttt{set\_mc\_group} method in actions or apply blocks to set a replication group for the packet.
To create copies of the packet, programmers can invoke the two-arguments \texttt{apply} method which is analogous to fork system call in C. 
The first argument provides an instance of \texttt{es\_t} with out port already set for the replica of the packet.
The second argument having \texttt{out} direction provides packet instance id to identify the replica.
All the reachable program statements from the method call statement are executed by every replica.

The \texttt{mc\_engine} has two more methods, \texttt{set\_buf} and four-arguments \texttt{apply}, to facilitate invocation of callees with multicast interface.
For example, had \texttt{ipv4} and \texttt{ipv6} implemented using multicast interface, the \texttt{forward} table in the \texttt{Router} $\mu$s-program have to be applied on all the copies of partial packet.
The caller (\texttt{Router}) can cascade multicast processing on partial packets.
It can $(1)$ store the partial copies, generated by the callee, into an instance of \texttt{mc\_engine} using \texttt{set\_buf} and $(2)$ invoke the apply method to process each copy using subsequent statments). 

\subsubsection{Logical Buffer Extern}
\label{sec:logical}
\uarch declares three types of extern objects, \texttt{in\_buf}, \texttt{out\_buf}, \texttt{mc\_buf}.
Among the three buffer externs, programmers can use \texttt{in\_buf} and \texttt{out\_buf} in the control block of orchestration pipeline to invoke other programs.
The \texttt{in\_buf} extern has \texttt{dequeue} method that is used only by the logical device \ulang. 
However, programmers can instantiate the extern and use its instances to pass as arguments to callee $\mu$s-programs.
The \texttt{out\_buf} extern has methods, \texttt{enqueue} and \texttt{merge}, to store packets processed by callees.
In addition, the extern provides \texttt{to\_in\_buf} to move the elements of the caller instance to the instance of \texttt{in\_buf} provided in the argument.
The \texttt{mc\_buf} extern allows to store parsed headers, unlike \texttt{in\_buf} and \texttt{out\_buf} externs.
It is designed to  be used along with \texttt{mc\_engine} to express multicast packet-processing, where as \texttt{in\_buf} and \texttt{out\_buf} are facilitates packet-processing model of \ulang.
An example usage of \texttt{enqueue} method of \texttt{out\_buf} is shown in Figure \ref{fig:multi-packet-processing}.
\hse{TODO: text for Figure \ref{fig:multi-packet-processing} or \ref{fig:multi-packet-processing-II}}

\begin{figure}[h]
\begin{lstlisting}[frame=none, escapechar=!]
struct out_t { /* empty */ }
control mc(pkt p, hdr_t h, sm_t s, es_t e, !\colorbox{mygray}{mc\_buf<hdr\_t, out\_t> hb}!) {
  !\colorbox{mygray}{mc\_engine mce;}!  PktInstId_t id; 
  out_t  oa;
  action replicate(GroupId_t gid) {
    !\colorbox{mygray}{mce.set\_mc\_group(gid);}!
  }
  table MulticastRouting{
    key = { h.ipv4.dstAddr : exact; } 
    actions = { replicate; }
  }
  table mac{
    key = { es.get_port() : exact; } 
    actions = { mac_update; }
  }
  apply {
    MulticastRouting.apply();
    !\colorbox{mygray}{mce.apply(es, id);}!//similar to C's fork
    mac.apply();
    hb.enqueue(h, sm, es, oa);
  }
}
\end{lstlisting}
\caption{Multicast Example}
\label{fig:multicast-example}
\end{figure}

\begin{figure}[!h]
 \begin{lstlisting}[frame=none]
struct e_t {};  struct h_t { ... };
prog(pkt, inout sm_t, es_t, out h_t);
test(pkt, inout sm_t, es_t, out h_t);
log(pkt, inout sm_t, es_t, in h_t, in h_t);
control validate(pkt p, inout sm_t s, es_t e, out_buf<e_t> ob) {
          pkt pt, pm;  es_t et, em;  
/*slice*/ sm_t st, sm; h_t hp, ht;
/*  #  */ apply {
/*  1  */   pm.copy_from(p); // c1
/*  1  */   em.copy_from(e); sm = s;
/*  3  */   pt.copy_from(p); // c3 
/*  3  */   et.copy_from(e); st = s;
/* 2,1 */   prog.apply(p, s, e, hp); 
/* 3,1 */   test.apply(pt, st, et, ht); 
/*  1  */   if (hp != ht) {
/*  1  */     log.apply(pm, sm, em, hp, ht);
/*  1  */     ob.enqueue(pm, sm, em);
/*  1  */   }
/*  3  */   smt.drop = true;
/*  2  */   ob.enqueue(p, sm, e);
/*  3  */   ob.enqueue(pt, smt, et);
          }
       }
\end{lstlisting}
\caption{Multi-Packet Processing}
\label{fig:multi-packet-processing}

\begin{lstlisting}[frame=none]
struct e_t {};
sflow(pkt, inout sm_t, es_t);
control con(pkt p, inout sm_t s, es_t e, out_buf<e_t> ob) {
  pkt ps;  es_t es;  sm_t ss;
  in_buf<e_t> ib;
  apply {
    ps.copy_from(p);
    es.copy_from(e); ss = s;
    sflow.apply(ps, ss, es); 
    ob.enqueue(ps, ss, es);
    ob.enqueue(p, s, e);
    ob.to_in_buf(ib);
    router.apply(ib, ob);
  }
}
\end{lstlisting}
\caption{Multi-Packet Processing II}
\label{fig:multi-packet-processing-II}
\end{figure}








\section{MicroP4 Compiler}
\label{sec:compiler}
\ucomp transforms parsers and deparsers of the main and callee package types into match-action control blocks.
It synthesizes new parser and deparser for the main package.
The synthesized parser accepts every packet with length greater than the minimum length, called \emph{min-packet-size}, derived by static-analysis of the program.
For every accepted packet, the synthesized parser at most extracts a fixed number, called \emph{extract-length}, of bytes to a stack, called \emph{byte-stack}, of one-byte headers.
Programs may increase or decrease size of packets, therefore, the estimated size of byte-stack can be greater than extract-length.
The synthesized deparser emits all valid one-byte headers from the byte-stack.


We perform compile-time analysis of parser, control and deparser blocks to estimate min-packet-size, extract-length and the size of byte-stack to process packets, as explained in section \ref{subsection:extract-length-and-byte-stack-size}. 
\ucomp executes transformed parsers and deparsers in the match-action stages using the byte-stack.
For each program, \ucomp creates metadata variables, called \texttt{field-variables} for the header fields used in the program's control block.
The header fields are substituted with the metadata variables in control blocks of the program.
\ucomp discards types and instances of the headers of each package.
\ucomp synthesizes a single bit \emph{valid} metadata variable for each header instance to record its presence in the packet.
\texttt{setValid} and \texttt{setInvalid} method-call statements of every header instance is replaced with assignments on the related \emph{valid} metadata variable.
Execution of parsers in match-action stages copy values from the appropriate locations in the byte-stack to the variables.
It also updates valid metadata variables which are later used by the deparser to copy back field-variables to byte-stack.


\hs{TODO: say Simple parser is a parser without stacks and variable-length header. 
Section \ref{subsection:parser-to-match-action-table} discuss about converting simple parser into a match-action table. Section \ref{subsection:header-stacks-variable-length-headers} converts parsers with header stacks or variable-length header into simple parser}


\subsection{Extract Length and Byte-Stack Size}
\label{subsection:extract-length-and-byte-stack-size}
As \ulang allows nested calls of package instances, evaluation of extract-length and byte-stack size is a recursive process.
\ucomp performs symbolic execution to evaluates extract-length and byte-stack size of every callee package in every control path in the CFG of the caller's control block.


The symbolic execution of a parser block enumerates every possible path from the start to the accept state in the parse graph.
For every path, it computes total number of bytes extracted by \texttt{extract} method call statements.
The \texttt{extract} method call statements on a path are evaluated by increasing the number of extracted bytes by size of the header instance specified in the argument.
We define the length of a path $x$ in the parse graph a package $a$'s parser, $lp_{a}(x)$, as total number of bytes extracted from the start to the accept state.
And, the extract-length of a package $a$'s parser is defined as the longest path in its parse graph, as shown in (\ref{extract-length-parser}).
Programs' extract-lengths also depend on their callees in their control blocks.
For a package $a$'s control block, we define the extract-length, $lc_{a}(x)$, of a control path $x$ as the maximum number of bytes required to process all the callees in the path.
The extract-length of the package $a$'s control block is defined as longest path in the CFG (\ref{extract-length-control}).
\begin{align}
E_{p}(a)\; =& \; \max_{x}\left\{lp_{a}(x)\right\} \label{extract-length-parser} \\
E_{c}(a)\; =& \; \max_{x}\left\{lc_{a}(x)\right\} \label{extract-length-control} \\
\mathcal{E}l(a)\; =& \; E_{p}(a) + E_{c}(a) \label{extract-length-program}
\end{align}
A package $a$'s extract-length, $\mathcal{E}l(a)$, is sum of extract-lengths of its parser and control block.
It is necessary to discuss increase and decrease in packet size, before we explain our approach to estimate extract-length of a control path ($lc_{a}(x)$) and byte-stack size for a package.



To estimate maximum decrease on a control path, we consider that a packet contains all the header instances which are set to valid or invalid on the path.
The rationale behind considering this scenario is, if a packet already has a header instance, setting it to valid will not impact size. However, setting it to invalid will decrease the packet size.
Similarly for maximum increase, we consider that a packet does not contain any header instance that is set to valid or invalid on the path. 
We evaluate header instances' \texttt{setValid} and \texttt{setInvalid} method call statements on every path in the CFG of the control block.
We denote increase and decrease in packet size on a path $x$ in the CFG of control block of a package $a$ using $i_{a}(x)$ and $d_{a}(x)$, respectively.
Similarly, $\Delta(a)$ and $\delta(a)$ denote maximum increase and decrease in packet size by a package $a$.
$i_{a}(x)$, as defined in (\ref{increase-path}), is the sum of $(1)$ sizes of all the header instances for which the control path has \texttt{setValid} methods call statements and $(2)$ maximum increase in packet size by every callee package $cp$ on the path.
Similarly, $d_{a}(x)$ is computed as show in (\ref{decrease-path}).
% $d_{p}(x)$ is the sum of $(1)$ sizes of all the header instances for which control path \texttt{setInvalid} methods call statements and $(2)$ maximum decrease in packet size by all every callee program $cp$ on the path as shown in \ref{decrease-path}.
\begin{align}
i_{a}(x)\; =& \; \sum_{H.setValid() \in x} sizeof(H) + \sum_{cp.apply()\in x} \Delta(cp) \label{increase-path} \\
d_{a}(x)\; =& \; \sum_{H.setInValid() \in x} sizeof(H) + \sum_{cp.apply()\in x} \delta(cp) \label{decrease-path}
\end{align}
The header instances which are not emitted by the deparser but extracted by the parser of a package decrease their packet's size. 
$d_{p}(x)$ is incremented by the size of such header instances for every path $x$.
We define maximum increase $\Delta(a)$ and decrease $\delta(a)$ in packet size by a package $a$ as shown in (\ref{increase}) and (\ref{decrease}), respectively.
\begin{align}
\Delta(a)\; =& \; \max_{x} \left\{ i_{a}(x) \right\} \label{increase} \\
\delta(a)\; =& \; \max_{x} \left\{ d_{a}(x) \right\} \label{decrease}
\end{align}

% Callee packages may parse and deparse packets, thereby, increase or decrease size of packets.
% Caller packages must extract sufficient number of bytes to process callees' parsers. Also, Callers must have byte-stack size large enough to process their own deparsers along with callees'.

Now, we define the extract-length ($lc_{a}(x)$) of a control path $x$ in the CFG of package a $a$'s control block as a function of the callees' extract-length ($\mathcal{E}l(cp)$) and maximum decrease in packet size ($\delta(cp)$).
Let's assume that a control path $x$ invokes N number of callee packages in increasing order of their numbers. 
The $i$the callee may decrease the size of packet resulting in available bytes lesser than parser extract-length of (i+1)th callee package ($E_{p}(i+1)$).
Figure \ref{fig:sequential-callees} shows the execution scenario of two callee packages invoked in the same control path in the CFG of a caller's control block.
The ipv6 and ipv4 states in the parsers of callee1 and callee2 transit to the accept state.
There are two control paths in the control block of callee1. One invalidates mpls header instance and another sets a new header (ipv4) to valid.
A control path of the first callee removes the mpls header from the packet, thereby, decreasing the packet size by four bytes.
The subsequent callee extracts eth, IPv6 and IPv4 headers from the packet.
\ucomp parser should extract 78 bytes to process $(1)$ removal of mpls header by the first callee and $(2)$ the logest path (eth-IPv6-IPv4) in the parse-graph of the subsequent callee package.
\begin{figure}[!h]
    \centering
    \includegraphics[trim=0 396 487 0, clip,scale=0.5]{sequential-callees}
    \caption{Multiple Callees in a control path}
    \label{fig:sequential-callees}
\end{figure}
Therefore, we take into account extract-length of every callee package's parser along with maximum decrease in packet size by the callee's predecessors in the control path $x$ to compute $lc_{a}(x)$, as shown in (\ref{extract-length-control-path}).
\begin{align}
lc_{a}(x) \; =& \; \max_{p} \left\{ \left( \sum_{i=0}^{i<p} \delta(i) \right)+ \mathcal{E}l(p) \right\},&p \in [0,N] \label{extract-length-control-path} \\
\mathcal{B}s_{a} \; =& \; \mathcal{E}l(a) + \Delta(a) & \label{byte-stack-size-package}
\end{align}
Finally, we define byte-stack size of a package $a$, $\mathcal{B}s_{a}$ (\ref{byte-stack-size-package}), as the sum of its extract-length and maximum increase in packet size.
For the example shown in Figure \ref{fig:sequential-callees}, the byte-stack size of the caller is 98, 20 bytes (due to ipv4.setValid()) in addition of its extract-length.


\subsection{Parser To Match-Action Table}
\label{subsection:parser-to-match-action-table}
\begin{figure*}[!ht]
    \begin{subfigure}[b]{0.25\linewidth}
        \centering
        \includegraphics[trim=4 270 596 0, clip,scale=0.37]{parser-transformation-example}    
        \caption{An example P4 Parser}
        \label{subfig:parser}
    \end{subfigure}
    \begin{subfigure}[b]{0.26\linewidth}
        \centering
        \includegraphics[trim=0 285 794 0, clip,scale=0.37]{parser-example-se-1}
        \includegraphics[trim=0 285 794 0, clip,scale=0.37]{parser-example-se-2}
        \caption{Parser Symbolic Execution}
        \label{subfig:parser-symbolic-execution}
    \end{subfigure}
    \begin{subfigure}[b]{.47\linewidth}
    \centering
    \begin{lstlisting}[frame=none]
key = { b[12]++b[13]:exact; // rest Ternary
  b[20]; b[23]; meta.data1; meta.data2;
  b[53].isValid(); b[73].isValid();}
actions = { cp_eth_ipv4_tcp;
  cp_eth_ipv6_tcp; set_parser_error;}
const entries = {
  (x0800,_,x6,_,xFF,1,_):cp_eth_ipv4_tcp();
  (x86DD,x6,_,xFF,_,_,1):cp_eth_ipv6_tcp();
}
default_action : set_parser_error();
\end{lstlisting}
\vspace*{-10pt}
\caption{Match-Action Control Block}
\label{subfig:parser-mat}
\end{subfigure}
\caption{Parser to Control Block Transformation}
\label{fig:parser-to-control-block-transformation}
\end{figure*}

% P4 parser blocks describe parse graphs as state machines.
% Real target devices contain programmable parser module that can be programmed using parse graphs.
% From the design of programmable parser \cite{6665172}, we make following observations.
Programmable parsers \cite{6665172} are implemented as finite state machines using buffer, Ternary Content-Addressable Memories (TCAM) and Action RAM. 
TCAM matches values of current state, fields or variables to identify next state.
Based on the match, headers are copied from byte stream followed by current state update.
Programmable parsers essentially perform repeated match-action operations.
% Network packets are of finite length, hence they can be parsed in a finite number of ways.
Successful parsing of a packet is essentially finding a match for a finite number of bytes from a finite set of values.
Every path enumerated by symbolic execution identifies possible byte locations to match for extracting a set of headers instances.
We leverage match capability of TCAM in match-action stages to match simultaneously all possible byte locations pertaining to every path from start to the accept state.
The action associated with the matched entry copies values from the appropriate locations in the byte-stack to local metadata synthesized for used header fields. 

We describe transformation of parser to match-action control block using the example shown in figure \ref{subfig:parser}.
The parser has four states to extract standard Ethernet, IPv4, IPv6 and TCP headers of size 14, 20, 40 and 20 bytes, respectively.
In general, we consider that parser state may use any metadata or variable to transit to next state. 
As an example, \emph{tcp} state transits to the accept state based on value (0xFF) of \texttt{var\_y} variable which is updated by either \emph{ipv4} or \emph{ipv6} states.
The symbolic execution of the parser computes two possibles paths from the start state to the accept state.
It also computes byte locations for header (e.g., eth.ethType, ipv6.nexthdr, ipv4.protocol) fields used in select expressions of states in the path.
If the select expression depends on local variables, it performs Forward Substitution \cite{Padua:1986:ACO:7902.7904} on every path to eliminate data dependency.
Figure \ref{subfig:parser-symbolic-execution} shows evaluated parser states and two paths generated by symbolic execution with forward substitution.
Every extract method-call statement is transformed into assignments from the byte-stack to field-variables associated with the header instance passed as an argument to the method-call.
In addition, valid metadata variable pertaining to the header instance is set.
We synthesize match-key using union of the select expressions in all the states on every path.
The match-key also comprises valid bit flag of the last byte extracted on every path to consider packet-length in the byte-stack.
For each path, we synthesize an action (e.g., \texttt{cp\_eth\_ipv4\_tcp} in Figure \ref{subfig:parser-mat}) comprising assignment statements in all the states on the path.
We create a match-action entry for every path using case values in select expressions and the action synthesized for the path.
For example, in the first entry shown in Figure \ref{subfig:parser-mat}, x0800, x6, xFF are match-values for the first, third and fifth keys to parse byte-stack as ehternet, ipv4 and tcp headers.
The second and the forth keys can have any values, hence they are matched with don't care values.




% The select expression in transition statement could be a header field, metadata or local variable declared in the parser.
% The value of select expression of a state may depend on its ancestors' parser statements. <<as shown in diagram>>
% Therefore, we perform Forward Substitution on select expressions in evaluated instances of states
% % (https://dl.acm.org/citation.cfm?id=7904)
% on each path and eliminate such data dependency.

% We synthesise local binary variables, called \emph{visit},  for each parser state to track the state transition of the parser's FSM.
% For every evaluated instance of a parser state, we synthesise an action comprising its parser\-Statements and replace extract method call statements to assignment statements.
% The assignment statements copies bytes from the buffer array to header instances' fields according to their sizes.
% Next, we add pop method call with the header size as the argument to remove the header from the byte array.
% We insert setValid method call statement for the extracted header instances.
% We add an assignment statement to set visit variable associated with the parser state.

\subsection{Transformation To Simple Parser}
% \subsection{Header Stacks \& Variable-Length Headers}
\label{subsection:header-stacks-variable-length-headers}
\ulang allows to use of header stacks with their size known at compile-time. 
\ucomp replaces every header stack instance with multiple instances of the header type. 
It symbolically evaluates operations on the header stack instances and transforms them into appropriate built-in method calls of the instances.
P4 provides various sets of computations to use in parser and control blocks.
In parser blocks, programmers can use \texttt{next} and \texttt{last} operations to iterate through the stack.
These operations along with \texttt{lastIndex} can be used to write loops in parsers to extract instances in header stack.
\ucomp unrolls such loops by replicating the parse states in them.
Loop unrolling replaces relative referencing operations, \texttt{next} and \texttt{last}, with appropriate header instances in the state replicas.
P4 provides \texttt{push\_front} and \texttt{pop\_front} operations on stack instances to manipulate elements on top and bottom of the stack.
\ucomp transforms push\_front and pop\_front operations into series of assignments and built-in method calls of header instances.
For example, assume that \texttt{hs} is a header stack instance of size 3. 
\ucomp synthesize hs0, hs1, hs2 header instances to replace hs.
\texttt{hs\_inst.push\_front(1)} is replaced with \texttt{hs2 = hs1}, \texttt{hs1 = hs0} and \texttt{hs0.setInvalid()}.


\ulang allows programmers to define variable-length header types, however it imposes a constraint that their variable-length fields must contain integer number of bytes at run-time.
% \ucomp splits header type containing fixed and variable-length fields into multiple types, where each type contains either fixed-length fields or the variable-length field.
\ucomp transforms every parser state with two-argument extract method call, used to extract variable-length header, into a sub-parser.
It splits the header type of the instance in the first argument into multiple types, where each type contains either fixed-length fields or the variable-length field.
Every state in the sub-parser extracts a fixed-number of bytes from the packet bit stream.
The sub-parser contains a state having the second argument (variableFieldSize) as the expression in its select statement.
The select statement has case-list enumerating all possible values up to specified maximum size of the variable-length field.
For each select case, the sub-parser transits to a state extracting a fixed number of bytes in the variable-length field.
For example, if variable-length field has maximum size of 40 bytes, \ucomp creates 40 states extracting different number of bytes.
The explosion of number of states would only increase number of entries in the transformed match-action table of the parser.

% \begin{figure}[H]
% \begin{minipage}[c]{0.45\linewidth}
% \begin{lstlisting}[frame=none]
% header_t[3] hs;
% 
% hs.push_front(1);
% \end{lstlisting}
% \end{minipage}
% \begin{minipage}[c]{0.45\linewidth}
% \begin{lstlisting}[frame=none]
% header_t hs0, hs1, hs2;
% 
% hs2 = hs1;
% hs1 = hs0;
% hs0.setInvalid()
% \end{lstlisting}
% \end{minipage}
% \caption{Extern to }
% \label{fig:}
% \end{figure}



\subsection{Deparser To Match-Action Table:}
\label{subsection:deparser-to-match-action-table}
The deparser blocks of \uarch's pipelines are the control blocks with emitter as one of the parameters.
\ucomp replaces the emitter instance's emit method-call statements with match-action table to transform deparser into normal match-action control blocks.
The match-action table copies back field-variables to appropriate locations in byte-stack based on values of valid metadata variables associated with header instances. 
The control block of the pipeline may set or reset validity of header instances and, thereby, modifying the size of the packet.
In case of increase in packet size, byte-stack is always large enough to hold new headers.
If a deparser decreases the packet size, subsequent parsers may set \texttt{packet\_too\_short} error only if packet-length on the wire is less than the extract-length and greater than the min-packet-size for the main package.

The symbolic execution of a deparser derives the emit order of header instances in the block.
Using the size of header instances and the emit order, we compute offsets in byte-stack to copy back field-variables and to insert new header fields.
The match key comprises valid metadata variables associated with each header instance in the package.
For every possible combination of valid headers, we synthesize a series of operations on byte-stack as an action to copy field-variables and to move data in byte-stack.
The control block of callee1 shown in Figure \ref{fig:sequential-callees} invalidates the mpls header from packets if the execution follows a particular control path.
Recall that, the parser synthesized by \ucomp extracts 78 bytes in the stack.
If the execution follows control path invalidating mpls header, 60 bytes following the header should be moved up by the offset of 4 in the stack.
The synthesized action performs in-place copy of these 60 bytes. It invalidates the last 4 bytes.
If the control block execution sets ipv4 header instance to valid, bytes after the ipv6 header are pushed down by the offset of 20 to insert ipv4 header instance.

\hse{CONTinue refinement pass}

\subsection{Real-Target Specific Transformation}
\ucomp transforms the packages described using \ulang's data plane abstractions into a given real target specific ones.
\uarch defines logical pipelines and externs to provide abstraction for data plane pipelines.
As a part of data plane abstractions, \uarch allows to describe multiple packet processing in control blocks of its orchestration pipelines.
Programmers can create multiple copies of packets in the control blocks using \texttt{copy\_from} methods of \uarch externs to describe multi-packet processing.
\ucomp's transformations create copies of packet using externs provided by the architecture of the specified target.
\ucomp realizes multi-packet processing by identifying a packet-processing sub-graph, called a \emph{thread}, for every definition of a \texttt{pkt} instance.
% Existing target devices can not process multiple packets by the same thread at the same time.
Then, it prepares \emph{Packet-Processing Schedule} (PPS) of the threads in the program and maps it to packet-processing blocks of the target's architecture.
Some target architectures may impose constraint that PPSs must be serializable.
If \ucomp fails to find a serial PPS for such targets, it raises a compilation error. 


\subsubsection{Packet-Processing Schedule}
\ucomp extracts packet-processing threads from the control block of orchestration pipeline's interface while maintaining control and data dependencies.
To this end, it constructs a Program Dependence Graph(PDG) \cite{Ferrante:1987:PDG:24039.24041} and performs a series of transformations.

\ucomp treats parameter of orchestration control block or every \texttt{copy\_from} method call statement of \texttt{pkt} instance as its definition, because they initialize the instance.
We note that \texttt{pkt} instance argument in \texttt{copy\_from} method calls is only used or read.
Moreover, all other method call statements having \texttt{pkt} instances as arguments access (read and modify) the instances, such call statements are not considered as their definition statements.


We define \emph{access ranges} of a \texttt{pkt} instance's definition as span of program statements until the next definition of the instance in reached on every possible path in the PFG.
We merge overlapping access ranges of multiple definitions of the same \texttt{pkt} instance.
Non overlapping access ranges of the same instance are renamed to create one-to-one mapping between an instance and its access range.
Inspired from \emph{program slice} defined in \cite{Weiser:1981:PS:800078.802557}, we define \emph{packet slice} based on access ranges of \texttt{pkt} instances' definitions.
A packet slice of a \texttt{pkt} instance is an executable subset of PDG, which consists of all the program statements affecting the instance's value in overlapping access ranges of its definitions.
Packet slices can have multiple entry and exist points.
A set of definition statements of \emph{pkt} instance with overlapping access ranges is considered as a slicing criteria for a given packet instance.
We compute packet slices from the PDG of control block using a method similar to one described in \cite{Ferrante:1987:PDG:24039.24041}.
Specifically, we perform a graph traversal in reverse direction of edges from every statement at exit points in the access ranges until definition statements in the criteria set are reached.
The graph traversal continues until all possible definitions of every variable used in visited statement are reached.
If any variable or extern instance is involved in anti-dependency, it is resolved by introducing new variable and renaming.
An example program shown in Figure \ref{fig:multi-packet-processing} is sliced with respect to definitions of three instances \texttt{pm}, \texttt{p} and \texttt{pt}.


Packet slices of different instances may have common program statements due to control and data dependence.
Therefore, a packet slice may have method call statements processing different \emph{pkt} instances than one's definition statements used in slicing criteria.
For the program shown in Figure \ref{fig:multi-packet-processing}, slice 1 pertaining to instance \texttt{pm} shares program statements with slices 2 and 3 related to \texttt{p} and \texttt{pt}, respectively.
We create a packet-processing thread per instance by excluding such method call statements from every packet slice but maintain dependence among them by creating inter-thread dependence.
All the common program statements not accessing \texttt{pkt} instances are also excluded from threads.
We term such statements \emph{cps} nodes and maintain their control and data dependencies with the thread nodes.
We associate every thread with an identifier, \emph{thread-id}, and a set of group-ids, called \emph{clone-group}.
Every thread-id identifies a thread based on unique \texttt{pkt} instance processed by it.
Every group-id identifies set of threads that may process copies of the same packet instance.
In presence, of conditional statements like if-else and switch, a thread may process a copy of a packet from multiple possible clone groups.

% and clone-group identifies every possible \texttt{pkt} instances from which the thread's packet instance could be initialized.


We transform PDG to PPS graph by coalescing all the nodes in a thread to a single node while maintaining their control and data dependencies with cps and other thread nodes.
We synthesise a variable to transform every control dependency among thread nodes to a data dependency.
The thread, which is depended on, sets the variable with a constant value and the other thread uses the variable in predicate of new if-conditional statement to continue processing on the control path.
If a PPS has a directed cycle involving thread nodes, PPS is not serializable.
If the real target does not have capability to process multiple copy of a packet at the same time, 
\ucomp raises error and lists program statements involved in cycles.
However, a PPS can have cycles involving maximum one thread node and common program statements represented by cps nodes.
To decide execution thread for cps nodes, we compute strongly connected components of PPS graph.
In each component, there can be exactly one thread node and one or more cps nodes.
We further transform PPS into a directed acyclic graph by contracting each component into a single node.
PPS can still have cps nodes not part of any strongly connected component, such nodes can be executed as a part of any thread with which they have dependence.
We schedule such cps nodes while mapping the thread nodes to packet-processing blocks of target architecture.



% Every \texttt{apply} method call statement of \texttt{Multicast} or \texttt{Orchestration} type package gets transformed to a thread node in PPS.
% \texttt{enqueue}, \texttt{merge} and \texttt{to\_in\_buf} method call statements of \texttt{out\_buf} extern's instances capture dependence among such threads nodes in PPS.



\subsubsection{Mapping to Target Architecture}
\ucomp visits PPS nodes in topological order to map thread and cps nodes on target architecture.
Also, standard metadata (\texttt{sm\_t}) instances and logical extern instances (\texttt{es\_t} and \texttt{mc\_engine}) used in the program are translated into intrinsic metadata and extern provided by the target architecture.
\ucomp partitions the sub-program represented by each thread node in multiple packet-processing block according to pipeline model of the target architecture.

Let's consider v1model architecture of simple\_switch target device for an example.
We create a two-state, named ingress and egress, finite-state machine to capture restriction on usage of egress-spec, egress-port and queuing metadata in ingress and egress blocks.
Each state represents a set of assertions to be verified on program statements while visiting them in topological order.
State transition occurs when the graph traversal can not be continued due to absence of nodes without incoming edges.
In the ingress state, the graph traversal asserts that every visited statement is not $1$ a call of apply method of \texttt{mc\_engine}  and $2$ \texttt{get\_value method} methods of \texttt{egress\_spec}.
When the traversal can not progress any further state transition happens and we split the thread PDG into two PDGs of visited and non-visited nodes.
In the egress state, the graph traversal asserts every that visited statement is not a method call of \texttt{get\_egress\_port}.

There can be multiple edges representing control branches between the partitions.
We synthesize \emph{partition} metadata that is assigned a unique value for each control branch in the first partition.
The second partition uses the metadata and condition on their values to resume execution on appropriate control branch.
Also, partitioned code may access the same local declaration variables.
These shared local variables along with the \emph{partition} metadata are passed as user-defined metadata between ingress and egress control block.

We synthesize per packet user metadata to store thread-id.
A packet is processed by a thread only if the corresponding thread-id is set in the metadata. 
We enforce this condition by instrumenting thread code with an if-conditional statement.
At the end of each thread, next thread-id is set.

\hse{TODO: may be a diagram for 5.5}

\subsection{Implementation}

\section{Hardware Resource Consumption}

\section{Conclusion}

%-------------------------------------------------------------------------------
\bibliographystyle{plain}
\bibliography{main}


\appendix
\section{Declarations in \uarch}
\label{appendix:section:micro-switch-architecture}
% \begin{figure*}[h]
% \begin{minipage}[t]{.35\textwidth}
% \begin{lstlisting}[frame=none]
% extern pkt {
%   byte[] packet;
%   unsigned length;
%   void copy_from(pkt p);
% }
% extern emitter {
%   void emit<H>(pkt p, in H hdr);
% }
% \end{lstlisting}
% \end{minipage}\vline
% \hfill\begin{minipage}[t]{.22\textwidth}
% \begin{lstlisting}[frame=none]
% enum meta_t {
%   INGRESS_TIMESTAMP,
%   EGRESS_TIMESTAMP
% }
% struct sm_t {
%   bit<16> pkt_len;
%   bit<8> in_port;
% }
% \end{lstlisting}
% \end{minipage}\vline
% \hfill\begin{minipage}[t]{.41\textwidth}
% \begin{lstlisting}[frame=none]
% extern mc_engine {
%   mc_engine();
%   void set_mc_group(GroupId_t gid);
%   apply(es_t, out PacketInstanceId_t);
%   
%   set_buf(out_buf<O>);
%   apply(pkt, out sm_t, es_t, out O);  
% }
% \end{lstlisting}
% \end{minipage}
% \begin{minipage}[t]{0.40\textwidth}
% \begin{lstlisting}[frame=none]
% extern extractor {
%   void extract<H>(pkt p, out H hdr);
%   void extract<H>(pkt p, out H hdr, in bit<32> size);
%   H lookahead<H>();
% }
% extern es_t {
%   void set_out_port(in bit<8>);
%   bit<8> get_out_port();
%   bit<32> get_value(in meta_t ft);
%   void copy_from(es_t es);
% }
% \end{lstlisting}
% \end{minipage}\vline
% \hfill\noindent\begin{minipage}[t]{0.57\textwidth}
% \begin{lstlisting}[frame=none]
% extern in_buf<I> { // used only by architecture
%   dequeue(pkt, out sm_t, es_t, out I);
% }
% extern out_buf<O> {
%   enqueue(pkt p, in sm_t sm, es_t es, in O out_args);
%   void to_in_buf(in_buf<O>);
%   void merge(out_buf<O>);
% }
% extern mc_buf<H, O> {
%   enqueue(pkt, in H, in sm_t, es_t, in O);
% }
% extern void recirculate();
% \end{lstlisting}
% \end{minipage}
% \end{figure*}


% \begin{figure}[h]
% \begin{lstlisting}[frame=none]
% extern pkt {
%   // byte array representation
%   byte[] packet;
%   unsigned length;
%   void copy_from(pkt p);
% }
% extern emitter {
%   void emit<H>(pkt p, in H hdr);
% }
% extern extractor {
%   void extract<H>(pkt p, out H hdr);
%   void extract<H>(pkt p, out H hdr, in bit<32> size);
%   /// H may be an arbitrary fixed-size type.
%   H lookahead<H>();
% }
% \end{lstlisting}
% \caption{Packet Representation}
% \label{fig:pkt-externs}
% \end{figure}

% \begin{figure}[h]
% \begin{lstlisting}[frame=none]
% enum meta_t {
%   INGRESS_TIMESTAMP,
%   EGRESS_TIMESTAMP
% }
% extern es_t {
%   void set_out_port(in bit<8>);
%   bit<8> get_out_port();
%   bit<32> get_value(in meta_t ft);
%   void copy_from(es_t es);
% }
% \end{lstlisting}
% \caption{\texttt{es\_t} extern}
% \label{fig:msa-egress-spec-extern}
% \end{figure}
% 
% \begin{figure}[h]
% \begin{lstlisting}[frame=none]
% extern in_buf<I> {
%   // used by architecture only
%   dequeue(pkt, out sm_t, es_t, out I);
% }
% extern out_buf<O> {
%   enqueue(pkt p, in sm_t sm, es_t es, in O out_args);
%   void to_in_buf(in_buf<O>);
%   void merge(out_buf<O>);
% }
% extern mc_buf<H, O> {
%   enqueue(pkt, in H, in sm_t, es_t, in O);
% }
% \end{lstlisting}
% \caption{Buffer Representation}
% \label{fig:pkt-buf}
% \end{figure}
% dequeue(pkt, out H, out sm_t, es_t, out O);

% \begin{figure}[h]
% \begin{lstlisting}[frame=none]
% // This can only be used in control block of multicast interface
% extern mc_engine {
%   mc_engine();
%   void set_mc_group(GroupId_t gid);
%   apply(es_t, out PacketInstanceId_t);
%   
%   set_buf(out_buf<O>);
%   apply(pkt, out sm_t, es_t, out O);  
% }
% \end{lstlisting}
% \caption{Multicast Extern}
% \label{fig:msa-multicast-extern}
% \end{figure}


\begin{figure*}[h]
\begin{lstlisting}[frame=none]
// Unicast
Unicast<H,M,I,O,IO>(pkt p, inout sm_t sm, es_t es, in I in_param, out O out_param, inout IO inout_param) {
  parser u_parser(extractor ex, pkt p, out H hdr, inout M meta, inout sm_t sm, in I in_param, inout IO inout_param);
  control u_control(pkt p, inout H hdr, inout M m, inout sm_t sm, es_t es, in I in_param, out O out_param, inout IO inout_param);
  control u_deparser(emitter em, pkt p, in H hdr);                             
}

// Multicast
Multicast<H,M,I,O>(pkt p, in sm_t sm, es_t es, in I in_param, out_buf<O> ob) {
  parser m_parser(extractor ex, pkt p, out H hdr, inout M meta, in I in_param, inout sm_t sm);
  control m_control(pkt p, inout H hdr, inout M meta, inout sm_t sm, es_t es, inout I in_param, mc_buf<H,O> mob);
  control m_deparser(emitter em, pkt p, in H hdr);
}

Orchestration<I,O>(in_buf<I> ib, out_buf<O> ob) {                         
  control o_control(pkt p, inout sm_t sm, es_t es, in I in_param, out_buf<O> ob);
}    
\end{lstlisting}
\caption{Programmable Blocks for Interfaces}
\label{fig:programmable-blocks-for-interfaces}
\end{figure*}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%  LocalWords:  endnotes includegraphics fread ptr nobj noindent
%%  LocalWords:  pdflatex acks
